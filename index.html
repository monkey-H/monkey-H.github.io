
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Welcome to monkey-H&#8217;s blog</title>
  <meta name="author" content="monkey-H">

  
  <meta name="description" content="写在前面 dokku，号称只用了100行左右代码就实现的简单paas平台，号称是你能见到的最小的paas平台，确实，很NB。整个dokku的实现大部分采用了bash脚本命令，只有少数的go语言文件，我们接下来就通过几篇blog，来看看，dokku到底是怎么实现的这个pass平台。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://monkey-h.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Welcome to monkey-H's blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Welcome to monkey-H&#8217;s blog</a></h1>
  
    <h2>学习日记</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="monkey-h.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/dokkuyuan-ma-jie-du-san/">Dokku源码解读三</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-04T18:48:02+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:48 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>写在前面</h3>

<p>dokku，号称只用了100行左右代码就实现的简单paas平台，号称是你能见到的最小的paas平台，确实，很NB。整个dokku的实现大部分采用了bash脚本命令，只有少数的go语言文件，我们接下来就通过几篇blog，来看看，dokku到底是怎么实现的这个pass平台。</p>

<h3>dokku文件源码解读</h3>

<p>上一节说到执行dokku receive $APP，找到文件中对应的代码
<img src="/Users/monkey/Documents/dokku/codereading/photo/dokku-receive.png" alt="dokku-receive.png" />
其实，在执行这段代码之前，还有一些命令要执行，这些命令是主要是一些准备工作，包括环境变量的设置，插件的安装激活，还有原始命令的执行。
在receive的case里面，主要做了四件事情，包括cleanup，build，release和deploy。
<img src="/Users/monkey/Documents/dokku/codereading/photo/dokku-cleanup.png" alt="dokku-cleanup.png" />
cleanup主要有两行命令组成，第一行，是删除paas平台中，状态为推出的container，可以看到，他是直接通过docker的命令执行的。关于docker，如果没有接触过的话，可以看看<a href="docker.com" title="docker 官网">这里</a>。第二行命令，是删除一些没有打标签的image，这些image一般是在生成新的image的过程中产生的临时文件。
build是用来产生要部署的程序的image的。build和release的case在plugins/00_dokku-standard/command里面可以找到。
<img src="/Users/monkey/Documents/dokku/codereading/photo/dokku-build.png" alt="dokku-build.png" />
dokku支持两种部署应用的方式，一种是heroku的标准格式，另外一种是dockerfile的格式，我们可以从代码的两个case中看到。我们先看简单的，dockerfile更加简单一些。
dockerfile的case中，第一步，查看dockerfile中有没有写EXPOSE，如果有，取出想要暴露的端口，并通过dokku config:set-norestart命令，设置成对应程序的环境变量。dokku config:set-norestart命令我们之后再解释。
<code>pluginhook pre-build-dockerfile "$APP"</code>
<code>pluginhook post-build-dockerfile "$APP"</code>
这两个插件在后来的更新中都去除了，所以，这两句不会执行。
还有一句<code>docker build -t .</code>这个是docker的标准的从当前路径，查找Dockerfile，生成image的语法，这样就生成了一个用来部署应用的image。
除了dockerfile的case，还有一个buildstep的case。在我们安装dokku这个paas平台的时候，就在makefile里面做了一个特殊的image
<img src="/Users/monkey/Documents/dokku/codereading/photo/buildstep.png" alt="buildstep.png" />
这个image是安装了heroku标准解释程序的image。而我们后来上传的按照heroku标准写的应用程序，就是通过这个东西来执行的。
<img src="/Users/monkey/Documents/dokku/codereading/photo/dokku-release.png" alt="dokku-release.png" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/dokkuyuan-ma-jie-du-%5B%3F%5D/">Dokku源码解读二</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-04T17:03:52+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:03 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>写在前面</h3>

<pre><code>dokku，号称只用了100行左右代码就实现的简单paas平台，号称是你能见到的最小的paas平台，确实，很NB。整个dokku的实现大部分采用了bash脚本命令，只有少数的go语言文件，我们接下来就通过几篇blog，来看看，dokku到底是怎么实现的这个pass平台。
</code></pre>

<h3>dokku进入点</h3>

<p>我们都知道git和ssh密不可分，从前面的知识我们也知道，当git push的时候，会首先执行ssh <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x2e;&#99;&#x6f;&#x6d;</a> git-receive-pack mygit.git这个操作，我们也说过了，这个会是dokku的入口。
我们停止服务器端的ssh服务，重新使用debug模式开启。
<code>sudo service ssh stop</code>
<code>sudo /usr/sbin/sshd -d</code>
然后在客户端重新部署一个服务，可以看到这样的提示。
<img src="/Users/monkey/Documents/dokku/codereading/photo/sshd.png" alt="sshd" />
我们去看看，/home/dokku/.sshcommand做了什么。
<code>cat /home/dokku/.sshcommand</code> <br/>
输出
<img src="/Users/monkey/Documents/dokku/codereading/photo/catsshcommand.png" alt="catsshcommand" />
这也就说明，不管你原来的命令是什么（$SSH_ORIGINAL_COMMAND），dokku都在这个命令前面增加了一个/usr/local/bin/dokku，也就是修改了客户端ssh进去的进入点，从而实现了进入pass平台部署任务的功能。
那么这个.sshcommand是怎么来的呢？我们去查看我们的安装文档，我这里是使用的vagrant安装的，我们可以去查看Vagrantfile文件。
<img src="/Users/monkey/Documents/dokku/codereading/photo/vagrantfile.png" alt="vagrantfile" />
在这里面，我们可以看到，这里只要是用的makefile安装的，我们接着查看Makefile。
<img src="/Users/monkey/Documents/dokku/codereading/photo/sshcommand.png" alt="sshcommand" />
这里可以看到，下载了一个脚本文件，然后执行了
<code>sshcommand create dokku /usr/local/bin/dokku</code>
命令，我们可以从makefile中找到SSHCOMMAND_URL的网址
<code>SSHCOMMAND_URL ?= https://raw.github.com/progrium/sshcommand/master/sshcommand</code>
进入到这个网址，我们可以看到
<img src="/Users/monkey/Documents/dokku/codereading/photo/sshcommandcreate.png" alt="sshcommand" />
也就是说，在安装dokku paas平台，这个地步的时候，加入了了这个进入点。</p>

<h3>dokku push流程（git插件文件夹解读）</h3>

<p>我们现在来浏览一遍，dokku完整的push一个应用都做了什么。
首先，我们先把dokku源码的目录整理一下。
<img src="/Users/monkey/Documents/dokku/codereading/photo/structure.png" alt="structure" />
其次，我们已经说过了，dokku修改了进入点，当执行git-receive-pack的时候，并不是直接直接执行，而是修改成了/usr/local/bin/dokku git-receive-pack，那么这样一来，就是调用dokku的命令了。我们从目录结构里面找到dokku文件，在这里面的case里面，并没有找到git-receive-pack这个case，但是，我们找到了一个通配的东西
<img src="/Users/monkey/Documents/dokku/codereading/photo/dokku-git*.png" alt="dokku-git*" />
从这里面可以看到，如果找不到对应的case，就去$PLUGIN_PATH/*/command里面去找，直到找到对应的东西。$PLUGIN_PATH路径下的东西就是我们源码中plugins路径下面的东西，我们可以直接在源码里面找。plugins里面的东西的命名还是很科学的，基本每个文件下的都是相关的hook。我们可以在plugins/git/command里面找到相关的东西</p>

<p><img src="/Users/monkey/Documents/dokku/codereading/photo/git-git*.png" alt="git-git*" />
这里当遇到是git-receive-pack命令的时候，就先初始化一个空的git仓库，然后写了一个脚本，给这个脚本附上可执行权限，并执行。脚本里执行的是
<code>dokku git-hook $APP</code>
同样的，我们在相同的文件里面，找到git-hook
<img src="/Users/monkey/Documents/dokku/codereading/photo/git-hook.png" alt="git-hook" />
这里主要是判断用户push是否push到了master分支上，如果没有，提示如何push，如果正确push了，就执行,说明这是一个新push的应用。
<code>pluginhook receive-app $APP $newrev</code>
既然是pluginhook方式的调用，我们肯定要在$PLUGIN_PATH里面查找这个文件了，这个文件也在git文件夹里面
<img src="/Users/monkey/Documents/dokku/codereading/photo/receive-app.png" alt="receive-app" />
可以看到，这里执行了
<code>dokku git-build $APP $REV</code>
<img src="/Users/monkey/Documents/dokku/codereading/photo/git-build.png" alt="git-build" />
这里有两个case，git-build判断是否这个app正在部署，或者被加锁了，否则就加锁，开始部署。git-build-locked就要开始真正的部署了。同样的文件夹找到git_build_app_repo()，
<img src="/Users/monkey/Documents/dokku/codereading/photo/git-build-app.png" alt="git-build-app" />
首先，检查一下app name，看看是否为空，或者是否不存在这个app目录，verify_app_name()这个函数在plugins/common/functions这里面，然后建造一个用来run这个应用的临时目录，并把应用拷贝到这个临时目录，最后，通过查看应用中有没有Dockerfile来判断，接下来执行的命令。但是不管有没有dockerfile，都会执行dokku receive命令。
终于，我们在dokku源码文件中，找到了receive的case分支。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/dokkudao-di-gan-liao-shi-yao/">Dokku源码解读一</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-01T09:05:19+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>9:05 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>写在前面</h3>

<p>dokku，号称只用了100行左右代码就实现的简单paas平台，号称是你能见到的最小的paas平台，确实，很NB。整个dokku的实现大部分采用了bash脚本命令，只有少数的go语言文件，我们接下来就通过几篇blog，来看看，dokku到底是怎么实现的这个pass平台。</p>

<h3>背景知识</h3>

<ul>
<li><p>git
  git是一个分布式版本控制软件，那么什么是版本控制呢？简单来说，版本控制就是一种记录一个或若干文件内容变换，以便将来查阅特定版本修订情况的系统，分为集中式版本控制和分布式版本控制。除了Git，还有像Mercurial，Bazaar，Darcs等。Git的客户端并只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来，这样的话，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复，因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。
  Git可以简单理解成客户端/服务器（C/S）模型，客户端就是客户使用的，用来上传repository和下载repository，修改repository的地方，那么服务器是什么东西呢？不要害怕，其实服务器端更简单。通俗点讲，服务器就是一个文件存储系统，push的时候，就是把本地的repository上传到这个服务器的某一个目录，clone的时候，就是把那个目录的文件下载下来而已，只不过在部署服务器，上传的时候，可能会做一些初始化而已，这都不是重点。
  关于Git我们这里就不再更多的介绍，大家可以在<a href="git-scm.com/book/zn" title="git中文介绍">这里</a>看到最详细的介绍，下面我们说一点dokku使用的Git的一个小技巧。
  当我们在客户端git push的时候，在服务器端，到底做了什么？当push的时候，首先，会通过ssh的密钥机制来检验你是否有资格push，如果有资格，那么在服务器端，接收到你push的命令的时候，会首先执行<code>ssh git@git-repositry.com git-receive-pack 'my-app.git'</code>这个命令。是不是很神奇，知道了这个，我们就知道了dokku平台的入口在哪里，那么，接下来，所有的事情都好解释了。</p></li>
<li><p>pluginhook
  pluginhook并不是被大家普遍使用的一个项目，这是dokku的原作者自己提出，并且用在自己的项目，比如dokku中的一个子项目。那么，这个项目是不是就很难理解？其实不是，如果换个名字，大家估计就会很熟悉，hook。Git本身就有hook机制，其作用主要是，当某些重要时间发生时，Git以调用自定义的脚本。在Git中，有两组挂钩，客户端和服务器端的。客户端主要用于客户端的操作，像你在commit的时候，可能同时希望可以提交和合并等，但是对一个paas平台而言，关注的更多是服务器端的hook脚本。服务器端的hook Git脚本，通常被一些开发者用来做自动部署，也就是说，当用户通过客户端git push操作后，服务器端在收到这个commit之前，之后，都可以自动调用.git/hooks目录下的一些脚本文件，并执行。非常适合自动部署，在用户push之后，不需要再到服务器端，执行部署工作。hook脚本的作用就是这样，那么pluginhook又做了什么事情呢？pluginhook的项目代码很少，只有不到200行的go语言的代码。是一个比hook本身更好的plugin system。相对于hook脚本，pluginhook更关注plugin，什么意思呢？就是说，他把所有的hook脚本都集中在一个plugins的目录里，当然，这个目录也是特定的目录，这样，操作系统才知道怎么去找plugin的目录。同一个hook脚本，可以有多个plugin，调用的时候，这些plugin都会去执行。简单来说呢，pluginhook就是对hook进行了一层封装，把原本调用hook脚本的地方，用pluginhook来调用，如hook脚本调用<code>hooks/post-commit $REV $USER</code>可以用pluginhook这样调用<code>pluginhook post-commit $REV $USER</code>，pluginhook命令就是简单的把plugin目录下的所有路径都找一遍，这个路径是通过环境变量$PLUGIN_PATH来定义的，只要找到和命令相同的文件的名字，就把这个命令之后的参数都传给这个文件，让他执行。那么，用pluginhook和hook有什么区别呢？可以这么说，不用pluginhook，只用hook也是可以完全实现这些功能的。使用hook，一是为了方便，二是，每个我们需要处理的点，只能有一个hook脚本实现，这是dokku所不希望的事情，所以，才有了pluginhook的出现。
  关于pluginhook的实现的代码阅读，我们之后再补充。</p></li>
<li><p>ssh
  ssh也是dokku修改的一个点，也是关于如何把git push后，在服务器端触发git-receive-pack的时候，默认调用dokku处理的部分。当我们在终端，将项目push到dokku平台的时候，假如我们打开dokku平台ssh服务的-x模式，也就是debug模式，我们可以看到这么一句话。
  <img src="https://github.com/monkey-H/monkey-H.github.io/tree/master/images/email.png" alt="email" />
  可以看到，dokku做了一件事情，他把所有的命令，都通过&#8220;这个文件一遍，这样就实现了进入dokku平台的自主控制界面，后面，他像干什么就干什么了。那么他是怎么实现这个功能的呢？这就和ssh的机制有关了。</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/bash-trick/">Bash 脚本语言学习收获</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-29T19:12:01+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>写在前面</h3>

<pre><code>之前一直以为脚本语言就是简单的一种编程语言，不需要过多的了解，只要知道一点皮毛，哪里用到哪里学习一下就可以了，但是，读了一段牛人写的bash脚本程序之后，看不懂，查了bash的基本语法，才知道，原来bash是这么牛掰的一门语言，准备花两天系统学习一下，今天看了一部分，记录一下自己觉得很有意思，之前不知道的东西。
</code></pre>

<h3>学习笔记</h3>

<ol>
<li><p>bash执行脚本的时候，会fork出来一个subshell来执行。那么，在脚本里设置的一些变量，就只有那个subshell知道，别的都不知道，也就是说，会被直接遗忘掉。使用export也是一样的效果。同时，注意在赋值的时候，是hello=”1”，不要忘记了没有空格和要有双引号。</p></li>
<li><p>如果不想开一个新的subshell来执行脚本，可以使用source script.sh这样来执行，这样就会在这个shell进程里来执行脚本，这样就可以保留里面设置的变量，包括export的环境变量，但是，结束了这个终端，也是不会被保留的。source在bash里面，可以使用.来替代。. script.sh也能达到这样的效果。</p></li>
<li><p>脚本文件第一行的#！尽量不要省略，这一行代表了这个脚本通过什么脚本命令程序来执行，如果你希望通过bash来执行脚本，但是没有指定，系统默认的又是别的脚本程序，那么就很有可能会出错。</p></li>
<li><p>当脚本出错的时候，如果想调试，没必要到脚本文件里面，通过注释代码的方式来调试，可以使用-x命令，bash -x script.sh来调试，这样，会让脚本文件一步一步执行，并在执行每一行命令前，打印出执行的哪一句命令，同时可以在脚本文件里加上，set -x …. set +x，来在常规执行的时候，就进入debug模式的一段代码。</p></li>
<li><p>按照惯例，bash的变量一般都是大写字母的组合，bash的变量有两种，一种是global variable，可以通过env或者printenv来查看，这些变量是在所有的shell里面都共用的。还有一种叫做local variable，这种变量只有在当前shell才有用。变量不能以数字开头。再次强调，在赋值的时候，等号周围是不能有空格的。可以通过unset 变量的方式，来把原来赋给变量的值清除掉。</p></li>
<li><p>一些特殊的值</p>

<ul>
<li>$0 当前脚本的名字，或者终端的名字。</li>
<li>$n 其中，n可以是1，2，3等，代表传入脚本的参数的值，不是从0开始的。</li>
<li>$# 参数的总个数。</li>
<li>$$ bash的进程id</li>
<li>$! 最近执行的后台命令的进程ID</li>
</ul>
</li>
<li><p>单引号可以让一些变量保持字面含义，比如echo ‘$date’ 输出是$date，而不是日期，同时，注意单引号不能嵌套单引号。但是双引号就不同了，双引号内，可以嵌套双引号，同时，如果加了$，是可以引用变量的，比如echo “$date” 输出的就不是$date，而是现在的日期。除了$，还有’’，echo “‘date’”和加$一样呢的效果。</p></li>
<li><p>一些小的trick
 echo sp{el,il,al}l
 spell spill spall
 (大括号的优先级是最高的)
 ~常被用来解析成$HOME，如~/path等。有两个特殊的应用~+代表的是当前路径，~-代表的是上一次进入的路径。
 允许通过:=的方式赋值，比如echo ${FRANKY:=FRIDY} 输出 FRIDY
 假如使用了”$(COMMAND)”的方式，那么，其中的所有字符都会被当做命令，而不会特殊处理。
 如果想在命令里进行计算，有两种方式，$((2+2)) 或者$[2+2]这两种方式，echo这两个结果，都是4</p></li>
<li><p>这是一个神奇的命令，是替代，别名的意思，我们可以使用这个东西来简化命令。
 比如，cd ../是回到上一层目录，假如我们使用alias ..=’cd ../’，然后，以后只要打..就可以回到上一层，如果想去除这个简写，只要unalias ..就可以了。当然这个修改只是暂时的，如果想一直这么做，就需要修改./bashrc或者/etc/profile文件。</p></li>
<li><p>正则表达式</p>

<ul>
<li>. 配对单个字符</li>
<li>? 代表最多一个字符，要么匹配，要么没有。</li>
<li>* 任意多个字符，可以没有一个</li>
<li>+ 和*一样，但是至少要匹配一次。</li>
<li>{N} 精确匹配N次</li>
<li>{N,} 精确匹配至少N次</li>
<li>{N,M} 精确匹配N到M次即可。</li>
<li>\ 下一个字符标记为一个特殊字符</li>
<li>| 匹配两边中的一个。</li>
<li>[xyz] 匹配其中的任意一个字符</li>
<li>[^ xyz] 匹配不是这三个中的字符，任意个</li>
<li>^xx 匹配某一行xx开头的文字</li>
<li>xx$ 匹配某一行xx结尾的文字</li>
<li>&lt;xx 某一个单词是xx开头的</li>
<li>>xx 某一个单词是xx结尾的。</li>
<li>- 表示范围。常用的就这么多，还有很多，百度一下，google一下就出来了。</li>
</ul>
</li>
<li><p>sed 是stream editor的简称，是一个编译器，具有很NB的功能。要注意的是，sed并没有修改文档的内容，只是打印修改后的文档。
基本命令：</p>

<ul>
<li>a 在当前行下添加文本</li>
<li>c 当前行变换内容</li>
<li>d 删除文本</li>
<li>i 当前行前增加文本</li>
<li>p 打印文本</li>
<li>r 读一个文件</li>
<li>s 查找并替代文本</li>
<li>w 写到一个文件
举个例子， <code>sed ‘/erors/p’ example</code>的意思就是，在example文件里面，查找有erors的行，并打印出来，假如我们这么写，那么就会把所有的文本都打印出来，只不过，有erors的行，打印两遍，所以我们要这么写<code>sed -n ‘erors/p’ example</code>
假如要删除，<code>sed ’/erors/d’ example</code>，这样就会删除有erors的行。
假如我们知道要删除的行是第几行，可以通过这么删除，<code>sed ‘2,4d’ example</code> 这样就删除了2-4行。同时可以使用正则表达式等。
<code>sed -n ‘/a text/,/This/p’ example</code>，这句话的意思就是，从example中匹配，打印从第一个包含a text的行，到保护This的那一行截止。
<code>sed ‘s/erors/errors’ example</code> 查找并替代。但是这样只会替代第一行，如果要替代所有的，需要<code>sed ‘s/erors/errors/g’ example</code>
如果多次查找和替换，需要使用-e参数。
<code>sed -e ‘s/erors/erros/g’ -e ‘s/last/final/g’ example</code>
同时，可以将结果输出到某一个文件。使用>即可。</li>
</ul>
</li>
<li><p>if语句。
注意在if [  ]的方括号里面，括号的左右是要有空格的。
常用的用来判断文件的一些参数。</p>

<ul>
<li>-a 存在即为真</li>
<li>-d 是否是个目录</li>
<li>-e 是否存在</li>
<li>-f 是否存在，且是一个常规文件</li>
<li>-r 是否可读</li>
<li>-s 是否大小不为0</li>
<li>-w 是否可写</li>
<li>-x 是否有执行权限
<code>if [ -f /home/monkey/hello ]</code>
<code>then</code>
<code>echo “file exist”</code>
<code>fi</code>
可以写成
<code>if [ -f /home/monkey/hello ]; then</code>
<code>echo “file exist</code>
<code>fi</code>
可以写成
<code>[ -f /home/monkey/hello ] &amp;&amp; (echo “file exist”)</code>
如果是当条件不满足做什么东西的时候，就是用||。
但是，一般很少用这种代码，大部分都会采用test这个内置命令，来检验一些问题。比如
上面的判断语句可以改为
<code>test -f /home/monkey/hello &amp;&amp; echo file exist</code></li>
</ul>
</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/hello-world/">Hello World</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-28T17:46:50+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:46 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>test 测试
<code>hello! world</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>haha 
</span><span class='line'>good night</span></code></pre></td></tr></table></div></figure>


<h1>标题一</h1>

<h2>标题2</h2>

<p>百度超链接 <a href="hello">www.baidu.com</a>
$$$2+2$$$</p>

<p><img src="/Users/monkey/Documents/octopress/source/favicon.png" alt="favicon.png" /></p>

<p>$$hello$$
|hello|</p>

<hr />

<hr />

<hr />
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/dokkuyuan-ma-jie-du-san/">Dokku源码解读三</a>
      </li>
    
      <li class="post">
        <a href="/blog/dokkuyuan-ma-jie-du-%5B%3F%5D/">Dokku源码解读二</a>
      </li>
    
      <li class="post">
        <a href="/blog/dokkudao-di-gan-liao-shi-yao/">Dokku源码解读一</a>
      </li>
    
      <li class="post">
        <a href="/blog/bash-trick/">Bash 脚本语言学习收获</a>
      </li>
    
      <li class="post">
        <a href="/blog/hello-world/">Hello World</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - monkey-H -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
