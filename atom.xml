<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Welcome to monkey-H's blog]]></title>
  <link href="http://monkey-h.github.io/atom.xml" rel="self"/>
  <link href="http://monkey-h.github.io/"/>
  <updated>2015-05-05T09:06:57+08:00</updated>
  <id>http://monkey-h.github.io/</id>
  <author>
    <name><![CDATA[monkey-H]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dokku源码解读三]]></title>
    <link href="http://monkey-h.github.io/blog/dokkuyuan-ma-jie-du-san/"/>
    <updated>2015-05-04T18:48:02+08:00</updated>
    <id>http://monkey-h.github.io/blog/dokkuyuan-ma-jie-du-san</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>dokku，号称只用了100行左右代码就实现的简单paas平台，号称是你能见到的最小的paas平台，确实，很NB。整个dokku的实现大部分采用了bash脚本命令，只有少数的go语言文件，我们接下来就通过几篇blog，来看看，dokku到底是怎么实现的这个pass平台。</p>

<h3>dokku文件源码解读</h3>

<p>上一节说到执行dokku receive $APP，找到文件中对应的代码
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/dokku-receive.png" alt="dokku-receive.png" />
其实，在执行这段代码之前，还有一些命令要执行，这些命令是主要是一些准备工作，包括环境变量的设置，插件的安装激活，还有原始命令的执行。
在receive的case里面，主要做了四件事情，包括cleanup，build，release和deploy。
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/dokku-cleanup.png" alt="dokku-cleanup.png" />
cleanup主要有两行命令组成，第一行，是删除paas平台中，状态为推出的container，可以看到，他是直接通过docker的命令执行的。关于docker，如果没有接触过的话，可以看看<a href="docker.com" title="docker 官网">这里</a>。第二行命令，是删除一些没有打标签的image，这些image一般是在生成新的image的过程中产生的临时文件。
build是用来产生要部署的程序的image的。build和release的case在plugins/00_dokku-standard/command里面可以找到。
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/dokku-build.png" alt="dokku-build.png" />
dokku支持两种部署应用的方式，一种是heroku的标准格式，另外一种是dockerfile的格式，我们可以从代码的两个case中看到。我们先看简单的，dockerfile更加简单一些。
dockerfile的case中，第一步，查看dockerfile中有没有写EXPOSE，如果有，取出想要暴露的端口，并通过dokku config:set-norestart命令，设置成对应程序的环境变量。dokku config:set-norestart命令我们之后再解释。
<code>pluginhook pre-build-dockerfile "$APP"</code>
<code>pluginhook post-build-dockerfile "$APP"</code>
这两个插件在后来的更新中都去除了，所以，这两句不会执行。
还有一句<code>docker build -t .</code>这个是docker的标准的从当前路径，查找Dockerfile，生成image的语法，这样就生成了一个用来部署应用的image。
除了dockerfile的case，还有一个buildstep的case。在我们安装dokku这个paas平台的时候，就在makefile里面做了一个特殊的image
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/buildstep.png" alt="buildstep.png" />
这个image是安装了heroku标准解释程序的image。而我们后来上传的按照heroku标准写的应用程序，就是通过这个东西来执行的。
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/dokku-release.png" alt="dokku-release.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dokku源码解读二]]></title>
    <link href="http://monkey-h.github.io/blog/dokkuyuan-ma-jie-du-%5B%3F%5D/"/>
    <updated>2015-05-04T17:03:52+08:00</updated>
    <id>http://monkey-h.github.io/blog/dokkuyuan-ma-jie-du-[?]</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<pre><code>dokku，号称只用了100行左右代码就实现的简单paas平台，号称是你能见到的最小的paas平台，确实，很NB。整个dokku的实现大部分采用了bash脚本命令，只有少数的go语言文件，我们接下来就通过几篇blog，来看看，dokku到底是怎么实现的这个pass平台。
</code></pre>

<h3>dokku进入点</h3>

<p>我们都知道git和ssh密不可分，从前面的知识我们也知道，当git push的时候，会首先执行ssh <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x67;&#105;&#116;&#x40;&#103;&#x69;&#116;&#46;&#99;&#x6f;&#109;">&#103;&#105;&#x74;&#64;&#103;&#105;&#116;&#46;&#99;&#111;&#109;</a> git-receive-pack mygit.git这个操作，我们也说过了，这个会是dokku的入口。
我们停止服务器端的ssh服务，重新使用debug模式开启。
<code>sudo service ssh stop</code>
<code>sudo /usr/sbin/sshd -d</code>
然后在客户端重新部署一个服务，可以看到这样的提示。
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/sshd.png" alt="sshd" />
我们去看看，/home/dokku/.sshcommand做了什么。
<code>cat /home/dokku/.sshcommand</code> <br/>
输出
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/catsshcommand.png" alt="catsshcommand" />
这也就说明，不管你原来的命令是什么（$SSH_ORIGINAL_COMMAND），dokku都在这个命令前面增加了一个/usr/local/bin/dokku，也就是修改了客户端ssh进去的进入点，从而实现了进入pass平台部署任务的功能。
那么这个.sshcommand是怎么来的呢？我们去查看我们的安装文档，我这里是使用的vagrant安装的，我们可以去查看Vagrantfile文件。
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/vagrantfile.png" alt="vagrantfile" />
在这里面，我们可以看到，这里只要是用的makefile安装的，我们接着查看Makefile。
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/sshcommand.png" alt="sshcommand" />
这里可以看到，下载了一个脚本文件，然后执行了
<code>sshcommand create dokku /usr/local/bin/dokku</code>
命令，我们可以从makefile中找到SSHCOMMAND_URL的网址
<code>SSHCOMMAND_URL ?= https://raw.github.com/progrium/sshcommand/master/sshcommand</code>
进入到这个网址，我们可以看到
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/sshcommandcreate.png" alt="sshcommand" />
也就是说，在安装dokku paas平台，这个地步的时候，加入了了这个进入点。</p>

<h3>dokku push流程（git插件文件夹解读）</h3>

<p>我们现在来浏览一遍，dokku完整的push一个应用都做了什么。
首先，我们先把dokku源码的目录整理一下。
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/structure.png" alt="structure" />
其次，我们已经说过了，dokku修改了进入点，当执行git-receive-pack的时候，并不是直接直接执行，而是修改成了/usr/local/bin/dokku git-receive-pack，那么这样一来，就是调用dokku的命令了。我们从目录结构里面找到dokku文件，在这里面的case里面，并没有找到git-receive-pack这个case，但是，我们找到了一个通配的东西
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/dokku-git*.png" alt="dokku-git*" />
从这里面可以看到，如果找不到对应的case，就去$PLUGIN_PATH/*/command里面去找，直到找到对应的东西。$PLUGIN_PATH路径下的东西就是我们源码中plugins路径下面的东西，我们可以直接在源码里面找。plugins里面的东西的命名还是很科学的，基本每个文件下的都是相关的hook。我们可以在plugins/git/command里面找到相关的东西</p>

<p><img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/git-git*.png" alt="git-git*" />
这里当遇到是git-receive-pack命令的时候，就先初始化一个空的git仓库，然后写了一个脚本，给这个脚本附上可执行权限，并执行。脚本里执行的是
<code>dokku git-hook $APP</code>
同样的，我们在相同的文件里面，找到git-hook
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/git-hook.png" alt="git-hook" />
这里主要是判断用户push是否push到了master分支上，如果没有，提示如何push，如果正确push了，就执行,说明这是一个新push的应用。
<code>pluginhook receive-app $APP $newrev</code>
既然是pluginhook方式的调用，我们肯定要在$PLUGIN_PATH里面查找这个文件了，这个文件也在git文件夹里面
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/receive-app.png" alt="receive-app" />
可以看到，这里执行了
<code>dokku git-build $APP $REV</code>
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/git-build.png" alt="git-build" />
这里有两个case，git-build判断是否这个app正在部署，或者被加锁了，否则就加锁，开始部署。git-build-locked就要开始真正的部署了。同样的文件夹找到git_build_app_repo()，
<img src="http://monkey-h.github.io/Users/monkey/Documents/dokku/codereading/photo/git-build-app.png" alt="git-build-app" />
首先，检查一下app name，看看是否为空，或者是否不存在这个app目录，verify_app_name()这个函数在plugins/common/functions这里面，然后建造一个用来run这个应用的临时目录，并把应用拷贝到这个临时目录，最后，通过查看应用中有没有Dockerfile来判断，接下来执行的命令。但是不管有没有dockerfile，都会执行dokku receive命令。
终于，我们在dokku源码文件中，找到了receive的case分支。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dokku源码解读一]]></title>
    <link href="http://monkey-h.github.io/blog/dokkudao-di-gan-liao-shi-yao/"/>
    <updated>2015-05-01T09:05:19+08:00</updated>
    <id>http://monkey-h.github.io/blog/dokkudao-di-gan-liao-shi-yao</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>dokku，号称只用了100行左右代码就实现的简单paas平台，号称是你能见到的最小的paas平台，确实，很NB。整个dokku的实现大部分采用了bash脚本命令，只有少数的go语言文件，我们接下来就通过几篇blog，来看看，dokku到底是怎么实现的这个pass平台。</p>

<h3>背景知识</h3>

<ul>
<li><p>git
  git是一个分布式版本控制软件，那么什么是版本控制呢？简单来说，版本控制就是一种记录一个或若干文件内容变换，以便将来查阅特定版本修订情况的系统，分为集中式版本控制和分布式版本控制。除了Git，还有像Mercurial，Bazaar，Darcs等。Git的客户端并只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来，这样的话，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复，因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。
  Git可以简单理解成客户端/服务器（C/S）模型，客户端就是客户使用的，用来上传repository和下载repository，修改repository的地方，那么服务器是什么东西呢？不要害怕，其实服务器端更简单。通俗点讲，服务器就是一个文件存储系统，push的时候，就是把本地的repository上传到这个服务器的某一个目录，clone的时候，就是把那个目录的文件下载下来而已，只不过在部署服务器，上传的时候，可能会做一些初始化而已，这都不是重点。
  关于Git我们这里就不再更多的介绍，大家可以在<a href="git-scm.com/book/zn" title="git中文介绍">这里</a>看到最详细的介绍，下面我们说一点dokku使用的Git的一个小技巧。
  当我们在客户端git push的时候，在服务器端，到底做了什么？当push的时候，首先，会通过ssh的密钥机制来检验你是否有资格push，如果有资格，那么在服务器端，接收到你push的命令的时候，会首先执行<code>ssh git@git-repositry.com git-receive-pack 'my-app.git'</code>这个命令。是不是很神奇，知道了这个，我们就知道了dokku平台的入口在哪里，那么，接下来，所有的事情都好解释了。</p></li>
<li><p>pluginhook
  pluginhook并不是被大家普遍使用的一个项目，这是dokku的原作者自己提出，并且用在自己的项目，比如dokku中的一个子项目。那么，这个项目是不是就很难理解？其实不是，如果换个名字，大家估计就会很熟悉，hook。Git本身就有hook机制，其作用主要是，当某些重要时间发生时，Git以调用自定义的脚本。在Git中，有两组挂钩，客户端和服务器端的。客户端主要用于客户端的操作，像你在commit的时候，可能同时希望可以提交和合并等，但是对一个paas平台而言，关注的更多是服务器端的hook脚本。服务器端的hook Git脚本，通常被一些开发者用来做自动部署，也就是说，当用户通过客户端git push操作后，服务器端在收到这个commit之前，之后，都可以自动调用.git/hooks目录下的一些脚本文件，并执行。非常适合自动部署，在用户push之后，不需要再到服务器端，执行部署工作。hook脚本的作用就是这样，那么pluginhook又做了什么事情呢？pluginhook的项目代码很少，只有不到200行的go语言的代码。是一个比hook本身更好的plugin system。相对于hook脚本，pluginhook更关注plugin，什么意思呢？就是说，他把所有的hook脚本都集中在一个plugins的目录里，当然，这个目录也是特定的目录，这样，操作系统才知道怎么去找plugin的目录。同一个hook脚本，可以有多个plugin，调用的时候，这些plugin都会去执行。简单来说呢，pluginhook就是对hook进行了一层封装，把原本调用hook脚本的地方，用pluginhook来调用，如hook脚本调用<code>hooks/post-commit $REV $USER</code>可以用pluginhook这样调用<code>pluginhook post-commit $REV $USER</code>，pluginhook命令就是简单的把plugin目录下的所有路径都找一遍，这个路径是通过环境变量$PLUGIN_PATH来定义的，只要找到和命令相同的文件的名字，就把这个命令之后的参数都传给这个文件，让他执行。那么，用pluginhook和hook有什么区别呢？可以这么说，不用pluginhook，只用hook也是可以完全实现这些功能的。使用hook，一是为了方便，二是，每个我们需要处理的点，只能有一个hook脚本实现，这是dokku所不希望的事情，所以，才有了pluginhook的出现。
  关于pluginhook的实现的代码阅读，我们之后再补充。</p></li>
<li><p>ssh
  ssh也是dokku修改的一个点，也是关于如何把git push后，在服务器端触发git-receive-pack的时候，默认调用dokku处理的部分。当我们在终端，将项目push到dokku平台的时候，假如我们打开dokku平台ssh服务的-x模式，也就是debug模式，我们可以看到这么一句话。<img src="http://monkey-h.github.io/Users/monkey/Document/dokku/sshd-x" alt="" />，可以看到，dokku做了一件事情，他把所有的命令，都通过&#8220;这个文件一遍，这样就实现了进入dokku平台的自主控制界面，后面，他像干什么就干什么了。那么他是怎么实现这个功能的呢？这就和ssh的机制有关了。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://monkey-h.github.io/blog/hello-world/"/>
    <updated>2015-04-28T17:46:50+08:00</updated>
    <id>http://monkey-h.github.io/blog/hello-world</id>
    <content type="html"><![CDATA[<p>test 测试
<code>hello! world</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>haha 
</span><span class='line'>good night</span></code></pre></td></tr></table></div></figure>


<h1>标题一</h1>

<h2>标题2</h2>

<p>百度超链接 <a href="hello">www.baidu.com</a>
$$$2+2$$$</p>

<p><img src="http://monkey-h.github.io/Users/monkey/Documents/octopress/source/favicon.png" alt="favicon.png" /></p>

<p>$$hello$$
|hello|</p>

<hr />

<hr />

<hr />
]]></content>
  </entry>
  
</feed>
