<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Welcome to monkey-H's blog]]></title>
  <link href="http://monkey-h.github.io/atom.xml" rel="self"/>
  <link href="http://monkey-h.github.io/"/>
  <updated>2015-09-07T19:11:07+08:00</updated>
  <id>http://monkey-h.github.io/</id>
  <author>
    <name><![CDATA[monkey-H]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[deis源码解读-go语言学习2]]></title>
    <link href="http://monkey-h.github.io/blog/deis-2/"/>
    <updated>2015-09-07T14:32:41+08:00</updated>
    <id>http://monkey-h.github.io/blog/deis-2</id>
    <content type="html"><![CDATA[<h4>写在前面</h4>

<p>又开始看代码了，NAP的编程进入了细节化阶段，不能再闭门造车了，看看deis的代码，看看别人是怎么做的。首先，要学习一下go语言是怎么用的。</p>

<!--more-->


<h4>go语言 复杂类型 方法 接口</h4>

<ul>
<li>go语言中也存在指针类型，其声明方式是p := &amp;i 或者 var p *int这样，注意，go语言中没有指针运算。</li>
<li>结构体就是一个字段的集合。
type Vertex struct {
  X int
  Y int
}</li>
</ul>


<p>func main() {
    fmt.Println(Vertex{1, 2})
    v := Vertex{1,2}
    v.X = 4
    p := &amp;v
    p.Y = 3
}
打印出来的是{1 2}
+ 结构体初始化的时候，可以通过{X:1, Y:2}这种方式初始化，如果省略了其中一个，比如Y，就是初始化的零值。
+ 数组 var a [2]string a[0]
+ 切片slice。s := []int{2,3,4,5} 可以通过这种方式访问，s[1:3], s[:3] s[2:]注意，s[a:b]是从a开始，到b-1结束。
+ slice除了以上面的方式构建，还可以通过make函数构建。a := make([]int, 5)，这个5就是slice的len。slice有两个函数要注意，一是len，一是cap。len(x) cap(x)，len是长度，cap是能够装的个数。make([]int ,0,5)第一个就是len，后一个就是cap。slice定义的时候可以不定义大小，通过append来增加输入。当超过cap的时候，会自动增加大小。
var a []int
a = append(a,1)
a = append(a, 2,3,4)
+ 通过for循环的range格式对slice循环。
func main(){
var pow = []int{1,2,3,4,5}
for i,v := range pow{
fmt.Printf(&ldquo;%d: %d \n&rdquo;, i,v)
}
}
这里的i，v就是小标和数字。
+ 如果用不到i，就用<em>来代替。for </em>, value := range pow
+ map和java的hashmap很像。
type Vertex struct{
Lat,Long float64
}
var m map [string] Vertex
m = make(map[string]Vertex)
m[&ldquo;hello&rdquo;] = Vertext{
1.3,2.9
}
注意，map在使用之前，必须用make来创建。没有make的map是空的，值为nil，并且不能赋值。
+ 另一种初始化方式。
var m = map[string]Vertex{
&ldquo;hello&rdquo;: Vertex{
1,2
},
&ldquo;world&rdquo;:Vertex{
3,4
},
}
+ m := make(map[string]int)
m[&ldquo;hello&rdquo;]=42
delete(m, &ldquo;hello&rdquo;)
v, ok := m[&ldquo;hello&rdquo;]判断有没有返回值。如果map中读取某个不存在的键时，结果是map元素类型的零值。
+ go语言中没有类的概念，但是可以在结构体类型上定义方法。比如
type MyFloat float64
func (f MyFloat) Abs() float64{
if f&lt;0 {
return float(-f)
}
return float64(f)
}
然后在后面就可以通过f.Abs()来调用。
+ 在结构体类型上定义方法的时候，注意，尽量用指针来做，用指针可以用来修改结构体变量的值，而不用指针的话，修改的只是一个拷贝，所以不会修改原来的值，是没有意义的。
+ go新开启一个线程。
+ channel是有类型的管道，默认情况下，在另一端没有准备好之前，接受都会阻塞，使得goroutine在没有明确的锁或者静态变量的情况下进行同步。不过channel和map和slice一样，都需要用make来创建一下才可以使用。c := make(chan int)后面的int代表之后要送进去的值。c &lt;- sum     x,y := &lt;-c,&lt;-c分别是加入一个值和推出一个值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[deis源码解读-go语言学习1]]></title>
    <link href="http://monkey-h.github.io/blog/deis-1/"/>
    <updated>2015-09-07T10:25:54+08:00</updated>
    <id>http://monkey-h.github.io/blog/deis-1</id>
    <content type="html"><![CDATA[<h4>写在前面</h4>

<p>又开始看代码了，NAP的编程进入了细节化阶段，不能再闭门造车了，看看deis的代码，看看别人是怎么做的。首先，要学习一下go语言是怎么用的。</p>

<!--more-->


<h4>go语言 函数变量循环判断语句</h4>

<ul>
<li>go语言和一般的java程序一样，都需要一个main函数，作为程序的入口。func main(){}</li>
<li><p>go语言也是可以引入别的现成的程序库和写好的程序。打包的方式：
  import (
  &ldquo;fmt&rdquo;
  &ldquo;math&rdquo;
)
或者
import &ldquo;fmt&rdquo;
import &ldquo;math&rdquo;</p></li>
<li><p>导入包之后，可以通过包加名称导出。在go语言中，导出的函数或者变量必须是大写的字母开头。比如在上面中，打印math中的pi。fmt.Println(math.pi)是不行的。当然，这是因为系统封装的math中没有pi，但是，就算是自己写的类，其中定义了pi，也是不能调用的，必须把pi改成Pi，大写字母开头才可以。</p></li>
<li>定义函数。func add(x int, y int) int { return x+y } 学到的东西，没有分号，定义函数通过func 函数名 然后参数可以多个，也可以没有，先写变量，然后类型，逗号，继续。返回值类型在最后。</li>
<li>当函数的参数同一个类型时，除了最后一个，都可以省略。func add(x, y int) int {}</li>
<li><p>func swap(x, y string) (string, string) {
  return y, x
  }
  func main() {
  a,b := swap(&ldquo;hello&rdquo;, &ldquo;world&rdquo;)
  fmt.Println(a, b)
  }
  从这里可以学到，多个返回值，用（）阔起来。=:后面在介绍。有多个返回值的时候，a,b即可。</p></li>
<li><p>函数返回值可以直接被命名。
  func split(sum int) (x, y int){
  x = sum /2
  y = sum *2
  }
  func main(){
  fmt.Println(split(18))
  }</p></li>
<li><p>var语句可以定义变量列表，同样的，类型定义在后面。
  var c, java bool
  int i
  注意，初始化，bool类型是false，int类型是0</p></li>
<li>var语句定义的变量也可以初始化，var i,j int = 1,2</li>
<li>:=用在一些变量类型明确的地方，可以用来替代var。比如，函数的返回值，已经生命了类型。或者变量声明的时候，初始化了true，string类型，这就很明显了。</li>
<li>基本类型：bool，string，int，int8，int16，int32，int64，uint，uint8，uint16，uint32，uint64，uintptr，byte（uint8的别称），rune（int32的别名），float32，float64，complex64，complex128</li>
<li><p>func main(){
  const f = &ldquo;%T(%v)\n&rdquo;
  fmt.Printf(f, x, x)
}
猜测这个的意思是打印x的变量类型（x的值）回车。</p></li>
<li><p>零值，对于int类型是0，对于string类型是空字符串，对于布尔类型，是false。</p></li>
<li>fmt.Printf(&ldquo;%q \n&rdquo;, s) fmt.Printf(&ldquo;%v \n&rdquo;, s)发现，如果s是string类型的，那么q输出有”“双引号，v没有。</li>
<li>go语言不通类型之间的类型转换，需要显示转换。var f float64 = float(s)</li>
<li>常量定义。const PI = 3.14不能用:=来定义。</li>
<li>定义常量也可以像import一样打包。const(big=1 small=2)</li>
<li>go只有一种循环，for循环，除了没有for后面的（），和java，c++的for循环是一样的,但是{}必须。</li>
<li>虽然go语言只有一种循环，但是for循环可以没有前置语句和后置语句，当没有这两个的时候，又可以省略分好，所以，这个时候的go语言的for语句，实际就是java中的while语句。</li>
<li>接上条，如果再省略判断语句，就是死循环了。类似于这种for{}这种。</li>
<li>同样的，if语句也是，没有（），其余的和java一样，但{}必须。但是不同的是，if语句可以在判断语句之前，加一个简单的语句，用分号隔开，比如：if var i int = 2; v&lt;2 {}.</li>
<li>switch语句也是这样，可以在前面加一个简单的语句，然后用分号隔开。不需要break语句，除非分支用fallthrough结束，否则分支会自动停止。</li>
<li>switch语句没有选择项的时候，就是相当于switch true，这样的话，可以在case语句里面加上判断，比如case x > 2: 这样也是可以的，相当于if else语句。</li>
<li>defer 语句会延迟函数的执行直到上层函数返回。</li>
<li>延迟的defer函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 14----新用户策略]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-14/"/>
    <updated>2015-07-29T07:50:36+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-14</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>我们的paas平台并不是任何人都可以使用，我们希望加入用户验证的功能，只有通过用户验证的用户，才可以使用nap。我们现在想做的是，用户验证部分在前台就做好，后台认为所有可以进来的用户，都是可以直接使用paas平台的。那么，在后台中，我们就要针对不同的用户，有一定的区别对待，使得让每个用户都觉得，他们是在独占使用nap平台的。</p>

<!--more-->


<h3>新用户策略</h3>

<p><img src="../../images/nap+architecture.png" alt="" /></p>

<p>在这里的时候，我们可以看到，对于不同的用户，我们应该有不同的数据存储区域。我们现在的做法是，在147这台机器上，不仅有用于存储的moosefs部分，还有总的逻辑控制部分controller，用来存储信息的database数据库部分，运行的应用容器部分，最后，还有针对不同的用户的数据存储部分。
针对每一个不同的用户，我们都有一个专门的容器，用来存储这个用户的所有数据文件，对于不同的用户，是不能互相访问的。而这个用户所有跑起来的应用容器，也应该直接挂载这个容器，从而所有的数据在所有的属于这个用户的容器中，应该都是可以看到的。这是我们的目的。同时，我们的前台有一个关于用户数据的部分，我们也希望直接通过这个数据容器，直接返回用户。</p>

<p>知道了为什么我们要有这个东西，接下来的问题就是，怎么设计这个东西。首先，由于controller要ssh到数据容器里面做事情，所以，ssh key是必须设置好，可以无密码访问的。其次，数据容器要挂载moosefs的存储，所以，moosefs的client也是必须有的。当然，还要挂载好moosefs。最后，在controller里面，要设置好容器的ip和名字的对应关系，方便查找。基本流程就是。</p>

<p>新的用户来了，查找是否已经存在这个用户，如果应经存在，就说明已经弄好了，不用再考虑，如果没有，那么，首先要启动一个容器，这个容器的image里面必须已经设置好了controller的key，然后，controller里面获得这个容器的ip，配置好域名和ip的对应关系。而在那个容器里面，要挂载moosefs的存储，其基本思路是，在moosefs master里面export的根目录下，新建一个文件夹，名字就是新的用户名，然后，挂载到这个对应用户名的目录下。这里面就需要做的一件事情就是要修改moosefs master里面的export的目录，和重启moosefs master服务。</p>

<p>这个还没有实现，等我测试好了逻辑控制层和操作系统层的分离，就开始写这个东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 13----代码拆分]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-13/"/>
    <updated>2015-07-28T07:38:22+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-13</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>我们前面已经做了很多事情，对基本的流程也有了一定的了解，那么现在我们可以做一些完善工作了，虽然这个完善工作的工作量也是巨大的。为了实现平台无关性，我们要想办法把控制逻辑部分，从操作系统层次剥离开来，把控制逻辑部分也在一个容器中实现。为了实现用户的个性化定制，我们需要区别对待不同的用户，把数据层隔离出来。为了实现用户的资源控制和数据信息的集中展示，我们需要数据库部分。等等。</p>

<!--more-->


<h3>nap结构再思考</h3>

<p>从前面的分析中，我觉得，我们新的nap平台的设计应该是这样的。</p>

<p><img src="../../images/nap+architecture.png" alt="" /></p>

<p>拆开来说，应该有以下几个部分。</p>

<p>deploy部分。</p>

<p><img src="../../images/nap+deploy.png" alt="" /></p>

<p>run部分</p>

<p><img src="../../images/nap+run.png" alt="" /></p>

<p>新用户部分</p>

<p><img src="../../images/nap+new+user.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 12----数据库服务设计]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-12/"/>
    <updated>2015-07-22T09:37:43+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-12</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>如果每次获取用户的部署的应用的信息，都需要使用fleet提供的接口进行一定的计算，甚至需要使用一些不友好的方式，比如使用ls来查看有多少个目录，就认为有多少个应用等方式的话，这样是非常的不美观的。我们需要增加一个数据库的组件，用来存储相应的信息，每次需要的时候，就从这里面读取，这样才是正统的设计方式。我们采用mysql来实现数据库服务。</p>

<!--more-->


<h3>数据库服务设计</h3>

<p>首先，我们存储了两张表格。一张用来存储service，另外一张用来存储app。名字就用这两个单词来命名。那么，我们都需要存储哪些信息呢？
对于service而言，我们需要知道这个service的名字，种类（mpi，mapreduce，profile等），如果是mpi或者mapreduce，还需要知道slave节点的个数。service的url，可以调节的参数，和已经部署运行的实例的个数，最后，我们要知道这个service是属于哪一个用户的，这个也很重要。
对于app而言，我们要知道这个app的名字，ip，port（对外界暴露的端口），boxport(使用shellinabox技术，需要知道暴露的端口)，启动命令（这个对以后启动应用很有用），最后就是这个app属于哪一个service。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> name </th>
<th style="text-align:center;"> kind </th>
<th style="text-align:center;"> slave_num </th>
<th style="text-align:center;"> url </th>
<th style="text-align:center;"> parameters </th>
<th style="text-align:center;"> instance_num </th>
<th style="text-align:center;"> fathername </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">monkey_dockerfile</td>
<td style="text-align:center;">dockerfile</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">github.com</td>
<td style="text-align:center;">arg1#arg2</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">monkey</td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th style="text-align:center;"> name </th>
<th style="text-align:center;"> ip </th>
<th style="text-align:center;"> boxport </th>
<th style="text-align:center;"> port </th>
<th style="text-align:center;"> command </th>
<th style="text-align:center;"> fathername </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">monkey_dockerfile_1</td>
<td style="text-align:center;">114.212.189.140</td>
<td style="text-align:center;">14596</td>
<td style="text-align:center;">14594#14595</td>
<td style="text-align:center;">python start.py</td>
<td style="text-align:center;">monkey_dockerfile</td>
</tr>
</tbody>
</table>


<p>当然，有了这些还不够，我们还需要有对应于数据库的一些操作的封装和实现。文件命名为mysql_treat。</p>

<p>刚开始，我们的思路是这样的，我们包含了以下一些基本的操作，实现对数据的每个部分的读取和设置。
注意，servicename,appname包含了username</p>

<ul>
<li>get_servicename_list(username) 返回用户服务列表</li>
<li>get_kind(servicename)返回服务的种类</li>
<li>set_kind(servicename, value)</li>
<li>get_slave_num(servicename)</li>
<li>get_url(servicename)</li>
<li>get_parameters(servicename)</li>
<li><p>get_instance_num(servicename)</p></li>
<li><p>get_appname_list(servicename)</p></li>
<li>get_port(appname)</li>
<li>get_ip(appname)</li>
<li>get_command(app_name)</li>
</ul>


<p>但是，后来我们发现，这些函数完全没必要命名的这么奇怪，这样会让编程人员记忆起来非常麻烦，我们可以只实现三个函数，但是这三个函数可以实现上面所有的功能。
- set_value(table, column, value, servicename_or_appname)
- get_value(table, column, servicename_or_appname)
- get_list(table, username_or_servicename)</p>

<p>还是编程经验少，如果多了，应该一开始就想到这种设计方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[随笔]]></title>
    <link href="http://monkey-h.github.io/blog/suibi/"/>
    <updated>2015-06-29T12:41:06+08:00</updated>
    <id>http://monkey-h.github.io/blog/suibi</id>
    <content type="html"><![CDATA[<h3>Q &amp; A</h3>

<p>实验过程中遇到的问题，与查到的解决办法，记录下来，以备不时之需</p>

<!--more-->


<h3>问题与解答</h3>

<p>Q: no journal files were found
A: fleetctl journal xxx.service不返回日志信息，sudo fleetctl journal xxx.service返回。原因是journal需要在systemd-journal权限组里才可以。但是，由于某些原因，比如网上说的：
I&rsquo;ve finally pinpoint the cause: I&rsquo;m logging in too early. Somehow, if you login after just few secs from the instantiation of the GCE machine, my user will not be added to the group systemd-journal. Thus, journalctl as normal user returns &ldquo;No journal files were found&rdquo;, while doing sudo journalctl returns the logs.
What&rsquo;s worse is that the situation is then permanent: even if I log out, the user will never be added to the group systemd-journal, but I guess I&rsquo;m in a limit scenario.
解决办法，
sudo usermod -a -G systemd-journal bob
id -a bob
但是对我没用。有一种简单粗暴的方法。
在用户目录/var/log/journal/machine-id/路径下
所有的文件的权限都是root的，改成nap的。
shdo chown nap ./*
就可以了。过于残暴，可能会引起某些问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 11----mapreduce应用]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-11/"/>
    <updated>2015-06-17T10:11:07+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-11</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>在前面的文章中，我们已经对mpi应用，maven工程应用做了一些介绍，那么转接到先部署，再启动的模式中，也只要对其有些修改即可，总体的设计理念是没有变化的。但是，我们现在要介绍的这个mapreduce应用却不是这样。mapreduce应用和mpi应用都属于多个容器支撑的应用，但是，mapreduce和mpi最大的不同是，mpi应用，只需要master节点知道所有的slave节点的ip地址即可。但是，mapreduce需要所有的节点，都知道其他节点的ip地址信息，这是一个很大的难点，我们接下来会详细叙述。</p>

<!--more-->


<h3>nap平台mapreduce应用设计分析</h3>

<p>在我看来，mapreduce应用的支撑设计，应该包括四个阶段。
- 跑起来masters,slaves
- 获取到这些masters，slaves的ip地址。
- 把这些ip地址都写入到masters和slaves中去。
- 让masters跑要跑的命令。</p>

<p>接下来，我们一条一条的说。</p>

<h4>启动masters和slaves</h4>

<p>这一条和之前设计的启动mpi的master和slave是一样的。通过一个unit启动master和slave，然后通过discovery来发现启动的容器的端口号等信息，并且写入到etcd中去，为下一步做打算。</p>

<h4>获取ip信息</h4>

<p>这一条也比较简单，前面已经把这些容器的ip信息都写入到了etcd中，所以，只要去etcd中去读取，并且记录下来就可以了。</p>

<h4>写入ip信息到master，slave中</h4>

<p>这一步其实是很有难点的。我们如何把这些ip信息写入到已经跑起来的容器中呢？虽然fleetctl ssh可以进入到一个容器中，但是，在bash命令中，那相当于重启了一个终端，如何把在这个终端中写入东西？我是一个bash新手，不会。但是我在想，是不是有一种重定向的设定，可以在里面写入命令。我之后会尝试查找这方面的内容，但是现在，我想到了另一种，虽然比较麻烦，但是感觉更加正确的方法。我用一个可以无密码登陆到master和slave的容器，这个容器就干一件事，把master和slave节点信息文件，scp到master和slave节点上去。</p>

<h4>让masters跑命令</h4>

<p>这也是一个难点。我们都知道docker logs只能输出第一线程的日志，我们这里跑起来master，slave的时候，已经不是第一线程了，所以，我们这里已经失去了一个最简单的获取日志的方式，但是我突然想到fleetctl journal和fleetctl cat的不同，好像这个可以解决。继续回到如何让master跑命令的问题，像上一个问题一样，我们不可能用docker exec -ti container /bin/bash这样，进去去执行，但是，我也希望通过上面的方法来解决这个问题。用一个可以无密码登陆到master节点上的container，这个container通过ssh的方式，使master运行需要运行的命令。</p>

<h4>总结</h4>

<p>好了，该说的都说了，继续实践。如果有问题，这里会继续补充。代码部分在github.com/monkey-h/nap</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的pass平台nap 10----统一接口规范]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-10/"/>
    <updated>2015-06-15T21:18:17+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-10</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>继续探讨一些统一接口，列出统一接口的名称，使用方法，和每个接口的功能。并通过大体流程的描述，详细叙述每个接口的功能。并把这篇文章最为web manager管理界面开发的时候参考的主要接口文档。</p>

<!--more-->


<h3>nap统一接口</h3>

<p>统一接口的一部分，想到其余的，再补。（注意这里的service和app是等同的，nap中跑的应用的命名规范为username_appname_mpi_master.service或者username_appname_mpi_slave@%i.service或者username_appname_common@%i.service）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- deploy_app(username_servicename, url): 上传应用，并不部署
</span><span class='line'>- list_services(username) 列出已经上传的应用
</span><span class='line'>- get_service_url(username, servicename) 得到部署的应用的url，这个url我们希望通过etcd来存储。存储的位置暂定为/services/url/username/appname
</span><span class='line'>- get_instances_num(username_service_name) 获得某个上传的应用的实例个数。
</span><span class='line'>- list_instances(username_servicename) 列出相同unit的不同应用，通过用户名和app名字进行匹配。
</span><span class='line'>- get_port(instancename) 获得跑起来的实例的端口号，通过etcd来设置。存放在/services/port/username/appname
</span><span class='line'>- get_journal(instancename) 获得某一个实例的运行日志。
</span><span class='line'>- stop_app(instancename) 停止某一个instance
</span><span class='line'>- start_app(instancename) 开始一个刚刚开始的应用
</span><span class='line'>- cat_app(instancename) 获得某一个instance的启动命令。
</span><span class='line'>- get_parameters(username_servicename) 获得某一个应用的可调参数列表。
</span><span class='line'>- start_common(username_servicename, para_str) 启动一个普通的应用。
</span><span class='line'>- start_mpi(username_servicename, para_str) 启动一个mpi应用。</span></code></pre></td></tr></table></div></figure>


<h3>接口进一步解释。</h3>

<p>从deploy开始。用户选择上传一个应用。deploy_app username_appname url，这个时候，服务器端，就是到/home/nap/services/username/username_appname路径下，下载对应url下的应用程序。那么list_services username，就是到这个路径下，有多少个文件夹就显示出来。同时，在deploy_app的时候，也在etcd的/services/url/username/appname路径下，存储url的值，为get_service_url做准备。接下来是start_common username_appname para_str这个命令，显然，在执行这个命令之前，要先执行get_parameters username_servicename，这个命令的作用是去读取用户程序文件夹下profile文件中的被{}包含的单词，我们认为这个单词是可以重新设定的可变参数，返回{}包含的单词，按逗号隔开的一个字符串，比如para1,para2。然后，用户需要填写这些参数对应的值，调用start_common函数，就可以部署一个应用。部署的过程就是，把/home/nap/services/username/username_servicename路径下的应用程序，拷贝到/home/nap/apps/username/username_servicename_num下，把可变参数用得到的参数列表替换，并且，注意命名，有个num，意思是这个文件夹下已经有的文件个数+1，这样可以避免重名。拷贝好，替换好之后呢，就可以start了，具体的start一个用例，我们在前面已经介绍的很清楚了，这里就不再介绍了。</p>

<p>当start好一个实例之后。用户调用get_instances_num service_name就可以获得service对应的instance有多少个，具体实现就是利用fleetctl list-units中所有的结果，和&lt;service_name_来进行匹配，有多少个，就输出多少。当然，list_instances也就解决了，用同样的方法。</p>

<p>还有cat_app 这个命名我们把他重构了，不再是fleet中的cat的作用了，我们现在把他定义为获得这个应用的profile文件。直接到对应的文件夹下去读就可以了。
get_port这个命令，是在start_common的时候，把这个程序的端口号，写到etcd的/services/port/username/appname这里，然后调用这个命令的时候，使用etcdctl get命令来做。</p>

<p>至于start_app stop_app get_journal这些命令，直接调用fleet的命令就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 9----统一paas平台入口]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-9/"/>
    <updated>2015-06-15T07:42:11+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-9</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>一个好的paas平台，并不只是提供了牛逼的功能，还在于好的交互。我们之前都是追求功能的完整性，在大体框架完成的时候，我们需要的还有较好的编程风格和交互，所以我们花一些时间思考一下关于同意paas平台入口的问题，这样，对于规范之后平台的开发，web manager管理界面的开发，都有很大的帮助。</p>

<!--more-->


<h3>统一paas平台入口</h3>

<p>在我们之前设计的nap（导师帮我起得paas平台的名字，寓意NJU Application Platform, Not Another Platform, take a nap we will do the rest等），平台一共有两个入口，分别是git push的时候，上传应用的入口，另一个就是在web manager管理界面的时候，用fleet的远程控制方法，endpoint来做的。在最初的设计过程中，这两个程序入口已经基本满足了我们的需求，但是在后面的设计过程中，我们发现，我们需要的不只是这两个入口，我们需要一些别的操作，需要新的入口作为支持。同时，这样两个入口，也是非常不美观不安全的。所以，为了进一步完成nap的设计，进一步完善nap的设计，我们准备统一nap的接口。</p>

<h3>ssh forced command</h3>

<p>继续我们之前只是简单介绍了一下的这个话题。在我们之前的设计中我们只是用<code>command="/home/nap/nap $SSH_ORIGINAL_COMMAND" ssh-rsa ~</code>这条命令改变了程序进入服务器的入口，但是，其实，这个东西可以做的东西，更多。我们之前的设计中，就是直接在/home/nap/nap中，执行了我们希望的流程，不过，这里面可以做一些判定语句，这些语句的作用有两个。一是，丰富nap的接口类型，数量。而是，限制nap用户可以使用的命令的范围，这也是为了平台的安全着想。比如，在/home/nap/nap中，我们用一个case语句。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>args=$*
</span><span class='line'>case $1 in
</span><span class='line'>  
</span><span class='line'>  #something i did before
</span><span class='line'>  git-receive-pack)
</span><span class='line'>      ./git_push_treat $args
</span><span class='line'>  ;;
</span><span class='line'>
</span><span class='line'>  #git push and only submit
</span><span class='line'>  submit)
</span><span class='line'>      ./submit_treat $args
</span><span class='line'>  ;;
</span><span class='line'>
</span><span class='line'>  #be aware of mpi maven and other projects
</span><span class='line'>  start)
</span><span class='line'>      ./start_treat $args
</span><span class='line'>  ;;
</span><span class='line'>
</span><span class='line'>  #just stop it
</span><span class='line'>  stop)
</span><span class='line'>      fleetctl stop $2
</span><span class='line'>  ;;
</span><span class='line'>
</span><span class='line'>  #list all submit services in cluster
</span><span class='line'>  list-services)
</span><span class='line'>      fleetctl list-units
</span><span class='line'>  ;;
</span><span class='line'>
</span><span class='line'>  #list all instances named like ${app}*
</span><span class='line'>  list-instances)
</span><span class='line'>      ./list_instances_treat $2
</span><span class='line'>  ;;
</span><span class='line'>
</span><span class='line'>  #list all machines
</span><span class='line'>  list-machines)
</span><span class='line'>      fleetctl list-machines
</span><span class='line'>  ;;  
</span><span class='line'>
</span><span class='line'>  #status of an instance
</span><span class='line'>  status)
</span><span class='line'>      fleetctl status $2 -l
</span><span class='line'>  ;;
</span><span class='line'>
</span><span class='line'>  #destroy an instance
</span><span class='line'>  destroy)
</span><span class='line'>      fleetctl destroy $2
</span><span class='line'>  ;;
</span><span class='line'>
</span><span class='line'>  *)
</span><span class='line'>      echo "no this command, try git push, submit, start and so on"
</span><span class='line'>esac</span></code></pre></td></tr></table></div></figure>


<p>这个case语句的作用就非常明显了，不在case语句中的命令，都会告诉用户，所需要的操作没有权限执行。其次，当执行到允许的操作的时候，有相应的操作对其进行配对。比较简单的，像status，destroy等都比较简单。但是有一些比较麻烦的，也是需要特殊处理一下的，比如。
- git-receive-pack
这个命令其实就是我们之前设计的paas平台的第一个接口，其实这里应该用不到了，但是，我还是保留了下来，这个主要是给我自己测试用的。当然，也可以给一些终端用户，而不是web管理界面用户使用。但是我们以后还会设计一个命令行工具，那个命令行工具支持终端用户使用这些命令，但是我们这里还没有设计，以后再论述。
- start
这条命令之所以单独提出来，也是因为这条命令有一些比较难以处理的情况，因为我们希望我们设计的程序支持多种类型，所以，在start的时候，是start了一个应用的多个实例，还是start了一个mpi应用，这些都是不可预知的，所以，我们可能希望通过不同的start命令，来实现这个功能。
- submit
这条命令的目的是，允许用户只是上传应用，并不是上传加部署，是git-receive-pack的简化版本。
- list-instance
这条命令，需求并不是列出所有的跑起来的应用，而是只列出和某个应用相关的应用。比如list-instance $APP，那么，就列出和这个APP相关的，比如这个APP的不同实例啊，如果是mpi应用，仅仅列出这个APP的slave和master之类的啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 8----支持mpi应用]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-8/"/>
    <updated>2015-06-10T07:08:09+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-8</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>之前我们已经实现了Dockerfile应用，maven应用的支持，现在，我们要加入另外一种类型，这种类型和之前的两种都不一样，这种应用和之前的应用的最大区别在于，这种类型的应用，并不是一个容器就可以完成的，需要多个容器配合，mpi和mapreduce应用就是这样，他们需要master slave节点，共同协作完成一件任务。我们这里先介绍mpi应用的设计，后面再介绍mapreduce应用的支持实现。</p>

<!--more-->


<h3>支持mpi应用</h3>

<p>我们之前花了那么长时间搭建flannel，配置mpi，跑mpi benchmark，时间可不是白花的，我们当然要把这个东西放到我们的paas平台之上。
我们先思考一下，我们这个paas平台已经做了什么东西，可以支持哪几种类型的应用。
- Dockerfile
- pom.xml
- profile</p>

<p>这三种，是我们最早可以支持的应用。对应来说，Dockerfile是最简单的形式，这是我们直接使用了Docker的规范，coreos原生支持Docker，这种形式来实现的，此处略过。第二种形式pom.xml，我们原本打算支持maven工程，所以有这么一个东西，如果工程里没有Dockerfile，但是有pom.xml，我们就用maven的镜像去mvn package这个工程，然后用profile里面的东西来跑。第三种，刚开始的时候只是一个权宜之计，本来是为了执行一些简单的脚本，不想把一些简单的应用转换为maven而存在的，但是后来发现其实这种东西非常有用，就直接保留了下来。
好的，那么，如果加入支持mpi的应用，那么mpi的这种格式规范应该和谁并列呢？是和上面叙述的这三个工程格式并列？还是在profile里面写一条支持mpi格式的一些判断？
我们最终的选择是，和上面这三种格式并列。</p>

<h3>mpi格式边排</h3>

<p>既然和上面三个对应了，那么像Dockerfile，pom.xml一样，我们要有个文件指示这是一个mpi应用，没有想到更好的名字，我们就叫mpi.xml文件好了。工程里如果有这个文件，我们就视为mpi应用。在mpi.xml里面，我们要有哪些东西呢？我们知道，如果要跑一个mpi应用，首先，我们要先编译，<code>mpicc ${APP}.c -o $APP</code>，然后，运行<code>mpirun -hostfile hostfile -n 4 $APP</code> 那么，我们的格式规范里，首先要有要编译的文件的名字，应用的名字（$APP_MASTER），要跑的节点的个数，至于host列表就不需要提供了，我们自动给他生成需要的节点的个数的容器。结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from: ${APP}.c
</span><span class='line'>to: ${APP}
</span><span class='line'>hosts: 4</span></code></pre></td></tr></table></div></figure>


<p>暂时就这些吧，跑一个hello world的例子足够了，等以后有了新的需求，或者为了更加完善，我们再加。</p>

<h3>paas解读mpi.xml</h3>

<p>ok，git push上去，解释脚本读取工程文件，遇到mpi.xml，判定为mpi工程。然后怎么做呢？我们都知道，我们之前部署的应用都是单节点的，那个比较简单，但是现在这个是多节点的，我们需要先跑起来hosts，然后master要依赖host列表来寻找slaves，然后在上面跑应用。
那么，首先，我们要先开一个容器，把mpi工程里的src文件读进去，里面放的主要是源代码，包含我们的${APP}.c文件。当然了别的文件，像数据data文件夹也都要读进去。然后在里面<code>mpicc ${APP}.c -o ${APP}</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while read line; do
</span><span class='line'>        key=$(echo $line | cut -f 1 -d ' ')
</span><span class='line'>        str=""
</span><span class='line'>        value=$(echo ${line/$key/$str})
</span><span class='line'>        case $key in
</span><span class='line'>                from:)
</span><span class='line'>                        FROM=$value
</span><span class='line'>                ;;
</span><span class='line'>                to:)
</span><span class='line'>                        TO=$value 
</span><span class='line'>                ;;
</span><span class='line'>                hosts:)
</span><span class='line'>                        HOSTS=$value
</span><span class='line'>                ;;
</span><span class='line'>                *)
</span><span class='line'>                        echo "other settings"
</span><span class='line'>        esac
</span><span class='line'>done &lt; $APPDIR/$APP/mpi.xml
</span><span class='line'>
</span><span class='line'>cd /$APPDIR/$APP
</span><span class='line'>cat &gt; $APPDIR/$APP/Dockerfile &lt;&lt;EOF
</span><span class='line'>FROM docker.iwanna.xyz:5000/hmonkey/openmpi
</span><span class='line'>MAINTAINER hmonkey &lt;5681713@qq.com&gt;
</span><span class='line'>COPY src /app
</span><span class='line'>WORKDIR /app
</span><span class='line'>RUN mpicc $FROM -o $TO
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>


<p>接着，我们要把刚刚那个container打包成一个镜像，上传到registry上面去，当然，这两步也可以用一个Dockerfile来解决。
再者，我们已经有了基础镜像，接下来就是以这个基础镜像为镜像，跑n个container作为slave，当然，这个要求我们的coreos cluster已经正确安装了flannel，因为我们要通过flannel来实现不同host节点上的container进行通信。这里面最难的部分是如何返回跑起来的container的ip地址。
最后，我们已经得到了host列表，我们只要开动一个master节点，在master节点上运行<code>mpirun --hostfile hostfile $APP</code>就可以了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat &gt; ${SLAVE_CONTAINERS} &lt;&lt;EOF
</span><span class='line'>[Unit]
</span><span class='line'>Description=slave containers
</span><span class='line'>Requires=docker.service
</span><span class='line'>After=docker.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>TimeoutStartSec=900m
</span><span class='line'>ExecStartPre=-/usr/bin/docker stop ${APP}_slave%i
</span><span class='line'>ExecStartPre=-/usr/bin/docker rm ${APP}_slave%i
</span><span class='line'>ExecStartPre=-/usr/bin/docker pull $REGISTRY/${APP}_image
</span><span class='line'>ExecStart=/usr/bin/docker run -P --name ${APP}_slave%i $REGISTRY/${APP}_image /usr/sbin/sshd -D
</span><span class='line'>ExecStop=/usr/bin/docker stop ${APP}_slave%i
</span><span class='line'>ExecStopPost=-/usr/bin/docker rm ${APP}_slave%i
</span><span class='line'>
</span><span class='line'>EOF
</span><span class='line'>
</span><span class='line'>fleetctl destroy ${SLAVE_CONTAINERS}
</span><span class='line'>
</span><span class='line'>fleetctl submit ${SLAVE_CONTAINERS}
</span><span class='line'>
</span><span class='line'>for ((i=1; i&lt;=$HOSTS; ++i))
</span><span class='line'>do
</span><span class='line'>  fleetctl destroy slaves_${APP}@$i.service &gt; /dev/null
</span><span class='line'>  fleetctl start slaves_${APP}@$i.service &gt; /dev/null
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>


<p>关于如何返回ip地址，我暂时的想法是，并不通过etcd，虽然也可以，但是由于etcd存在一定的延迟，我们后面会通过etcd来公布已经部署的应用，但是返回host列表，我想在每次成功部署一个container之后，就用docker inspcet (中间的参数我忘记了)，这种东西直接返回，然后启动多少个，我们就返回多少个，反正我们是集中式部署的container（但是部署的container是分布式的），收集起来比较容易。
上面的想法是多么的简单无知。fleetctl在部署应用的时候，是在部署应用的机器上，直接部署的，并不是集中式的部署，所以，还是要通过etcd，把部署的slave的ip地址写到etcd中，然后，再在master节点上读取，最后再运行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat &gt; ${DISCOVERY} &lt;&lt; EOF
</span><span class='line'>[Unit]
</span><span class='line'>Description=${APP}_discovery
</span><span class='line'>BindsTo=slaves_${APP}@%i.service
</span><span class='line'>After=slaves_${APP}@%i.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>ExecStart=/bin/sh -c "while true; do appip=\$(docker inspect --format='' ${APP}_slave%i); etcdctl set /services/mpi/$APP/slaves/slave%i \$appip --ttl 60; sleep 30; done"
</span><span class='line'>ExecStop=/usr/bin/etcdctl rm /services/mpi/$APP/slaves/slave%i
</span><span class='line'>
</span><span class='line'>[X-Fleet]
</span><span class='line'>MachineOf=slaves_${APP}@%i.service
</span><span class='line'>EOF
</span><span class='line'>
</span><span class='line'>fleetctl destroy ${DISCOVERY}
</span><span class='line'>
</span><span class='line'>fleetctl submit ${DISCOVERY}
</span><span class='line'>
</span><span class='line'>for ((i=1; i&lt;=$HOSTS; ++i))
</span><span class='line'>do
</span><span class='line'>        fleetctl destroy discovery_${APP}@$i.service &gt; /dev/null
</span><span class='line'>        fleetctl start discovery_${APP}@$i.service &gt; /dev/null
</span><span class='line'>done
</span><span class='line'>
</span><span class='line'>HOSTLIST=$(etcdctl get services/mpi/$APP/slaves/slave1)
</span><span class='line'>for ((i=2; i&lt;=$HOSTS; ++i))
</span><span class='line'>do
</span><span class='line'>  HOST=$(etcdctl get services/mpi/$APP/slaves/slave$i)
</span><span class='line'>  HOSTLIST="${HOSTLIST},${HOST}"
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 7----单应用多实例]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-7/"/>
    <updated>2015-06-09T07:45:41+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-7</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>前面一片文章说了关于配置多个实例的问题，其实我们应该更加深入的理解一下。很容易混淆的一个问题就是单应用多实例和一组类似应用的区别。而且，他们实现起来也是有很大差别的。下面我们对这个两个问题进行分别探讨，并分别实现，完成nap的更多功能。</p>

<!--more-->


<h3>单应用多实例 VS 一组类似应用</h3>

<p>我觉得，老板的理解不对。需求是这样的，一个应用，需要启动多次，但是每次启动的命令中的某个参数不同。那么，对传统意义上而言，这几个应用就是不同的应用，不能说是同一个应用的不同实例。对我们现在设计的paas平台而言，就应该是建立几个不同的文件夹，代表你要起的应用的个数，里面资源可以一样，但是你的启动命令不一样，这样就起来不同的应用了，当然，我也承认，这样确实比较麻烦。</p>

<p>所以，我思考了一下，单应用多实例和一群类似的应用是不一样的。单应用多实例，应该是同一个应用，完全相同，启动多个实例，这样的目的可能是为了比较同一个应用多次计算的结果是否一致，或者考虑到可靠性，即使其中的一个应用实例死掉，也是可以访问等。而一群类似的应用，可能就是因为他们的计算资源一致，或者只有起始命令不一样而已。那么，我们就针对这两个需求，做不同的事情。</p>

<h3>单应用多实例</h3>

<p>在我们的paas平台中，应该有两个地方需要体现。
第一，是在部署应用之前。在我们的源代码文件中，我们有个profile的文件，我们上篇文章中说过，可以通过在里面添加参数的形式来实现。我们这里就是增加了一个新的参数，scale。这个scale，就是单应用要启动的实例个数。然后，在解读profile文件的时候，读出这个值。至于启动部分，fleet有个机制可以满足，所谓的高可用应用的部署。是关于submit myapp@.service，启动的时候，启动start myapp@%i.service这种方式，这里的%i是一个数字，字母，或者其他，在service文件中，可以通过%i访问。启动的个数就通过一个for循环就可以了。代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while read line; do
</span><span class='line'>                        key=$(echo $line | cut -f 1 -d ' ')
</span><span class='line'>                        str=""
</span><span class='line'>                        value=$(echo ${line/$key/$str})
</span><span class='line'>                        case $key in
</span><span class='line'>                                memory:)
</span><span class='line'>                                        MEMORY=$(echo $line | awk '{ print $2 }')
</span><span class='line'>                                        DOCKER_MEMORY="-m $MEMORY"
</span><span class='line'>                                ;;
</span><span class='line'>                                scale:)
</span><span class='line'>                                        INSTANCES=$(echo $line | awk '{ print $2 }')
</span><span class='line'>                                ;;
</span><span class='line'>                                command:)
</span><span class='line'>                                        echo $value &gt;&gt; $APPDIR/$APP/run
</span><span class='line'>                                ;;
</span><span class='line'>                                *)
</span><span class='line'>                                        echo "other settings"
</span><span class='line'>                        esac
</span><span class='line'>                done &lt; $APPDIR/$APP/profile
</span><span class='line'>
</span><span class='line'># start instances of scales
</span><span class='line'>for ((i=1; i&lt;=$INSTANCES; ++i))
</span><span class='line'>do
</span><span class='line'>  fleetctl destroy $WORKDIR/${APP}@$i.service &gt; /dev/null
</span><span class='line'>  fleetctl destroy $WORKDIR/${APP}_discovery@$i.service &gt; /dev/null
</span><span class='line'>  fleetctl start $WORKDIR/${APP}@$i.service &gt; /dev/null
</span><span class='line'>  fleetctl start $WORKDIR/${APP}_discovery@$i.service &gt; /dev/null
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>


<p>毕竟并不是所有的用户都是程序员，都希望看到底层的显示，所以我们为之设计了一个web manager，虽然很丑，但是还在规划中。其主要思想就是通过fleetctl &ndash;endpoint机制，远程访问fleet里面的信息。那么，这个web manager也就是第二个地方我们要考虑的点。在这个地方，应该加一个按钮，这个按钮的作用就比较简单，就是单纯的扩大实例的个数。其中要注意的就是实例命名的问题，因为不能重复，在我们现在设计的paas平台中，如果应用重复，就是单纯的覆盖老应用，还是很不友好的，我们后面估计会花一点时间，单独思考一下关于命名冲突的问题。</p>

<h3>一组类似应用</h3>

<p>在我们的web界面中，我们有一个部署应用的界面。这个是怎么实现的呢？在你需要部署这个应用的时候，需要输入要部署的应用的url。得到这个url之后，我们这么做。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git@url
</span><span class='line'>git remote add iwanna iwanna@ip:app-name
</span><span class='line'>git push iwanna master</span></code></pre></td></tr></table></div></figure>


<p>稍微有点常识的人，一看就知道这是在干嘛。其实就是下载下来源码，然后push到我们的paas平台中去。同样的，我们这里部署一组类似应用的时候，也采用这种方式。
在某一个应用下面，点击部署相似应用的按钮，弹出一个对话框，需要你输入重新启动的命令。得到这个命令之后，我们就拿到了两样东西。第一，这组相似应用的名字，第二，这组相似应用的新命令，够了。
然后我们接下来要做的事情就是，按照相似应用的名字，把这个相似应用的文件下载下来，修改其中profile的command命令，重新push。当然，还是一个不能忽略的问题，命名问题。
伪代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>copy core@ip:/home/iwanna/apps/$APP /apps/${APP}_${NO} //这里应该是git clone，但是我们修改了服务器的入口，所以clone的时候并不是我们希望的操作，因为我们的paas平台上不只是有iwanna这一个用户，还有别的用户，所以我们这里直接用scp的方式来得到，临时的做法，后面应该会改成更加正式的做法。这里的NO是考虑到命名的问题，我们命名的规则就是，查看和这个应用已经类似的应用有几个了，然后在这数字上加一，前面加上应用名字，就是新的类似应用的名字。
</span><span class='line'>cd /apps/${APP}_${NO}
</span><span class='line'>#替换profile中的command
</span><span class='line'>
</span><span class='line'>git add *
</span><span class='line'>git commit -m "new app"
</span><span class='line'>git remote add iwanna iwanna@ip:${APP}_${NO}
</span><span class='line'>git push iwanna master</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 6----配置应用设置参数]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-6/"/>
    <updated>2015-06-08T09:08:40+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-6</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>很多时候，我们需要对应用进行一些配置信息。比如，需要的内存是多少，需要几个cpu来运行它，甚至要启动几个实例等。这些也是一个完整的paas平台所需要具备的功能。当然，nap也需要这个功能。</p>

<!--more-->


<h3>配置容器启动参数</h3>

<p>后来我发现，不只是容器的启动参数，我们可以设计的更多，很有可能，包括容器的内存，cpu设置，环境的依赖，甚至是对某些容器的依赖，某些服务的依赖，或者是container之间的link关系，都可以通过这个实现。
事情的起因是这样的。我有个师妹，想要跑一个程序，老板就说，干脆试一下我写了这么久的东西，可不可以用，跑起来试试。虽然后来是跑起来了，但是师妹去找了一个更帅的师兄。师妹的那个程序本身没有什么特殊的地方，但是，师妹那个程序是一个计算密集型的应用，需要比较多的内存和cpu，docker默认是可以使用所有宿主机本身的所有内存和cpu的，这个恰巧是符合用户需求的，但是，我们可能遇到一个情况，就是限制用户能够使用的内存和cpu，基于这个需求，我觉得有必要设计一个关于限制cpu，内存的机制。
问题来了，把关于这种限制，或者称为参数设置，加在哪里？首先，看看我们之前做的事情，都有了哪些文件，文件夹。第一个，data文件，用来存储程序可能需要的输入文件等，加在这里？不合适，我们希望专职专用，用来存放输入文件的地方，就用来存放输入文件就可以了。第二，pom.xml文件，这个是只有在应用类型是maven文件的时候才会有的文件，如果不是maven文件，就没有了，也不合适。第三，src文件夹，这个是用来存放源程序的地方，放参数设置信息，也不合适。还有一个是Dockerfile，Dockerfile是我们直接用的docker的文本语言规范，加进去也实在是不方便，放弃。还有最后一个，profile文件，这个文件之前被我们定义为存放起始命令的文件，其实，在这里面，我们可以加入更多。
首先想到的，肯定是我们的需求。我们本来就是希望可以加入关于内存的设置，这里，我们在profile里面原本只是一行起始命令的地方，加一些标记。比如，原本可能是
<code>sh hello.sh</code>
现在，我们这样写
<code>command: sh hello.sh</code>
为什么要加一个标记信息呢？因为我们后面，还要加上memory限制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>command: sh hello.sh
</span><span class='line'>memory: 1024m</span></code></pre></td></tr></table></div></figure>


<p>怎么样，这样一来，我们就可以解读道不同的行的时候，知道这行到底是干什么用的。
接下来，我们怎么解读呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#look for memory limit and others
</span><span class='line'>      MEMORY=$(grep memory: $APPDIR/$APP/profile | head -1 | awk '{ print $2 }')
</span><span class='line'>      if [ -z "$MEMORY" ]; then
</span><span class='line'>          echo "no memory limit"
</span><span class='line'>      else
</span><span class='line'>          DOCKER_MEMORY="-m $MEMORY"
</span><span class='line'>      fi
</span><span class='line'>
</span><span class='line'>#get out the entrypoint command
</span><span class='line'>      line=$(grep command: $APPDIR/$APP/profile | head -1)
</span><span class='line'>      null=""
</span><span class='line'>      COMMAND="${line/command:/$null}"
</span><span class='line'>      if [ -z "$COMMAND" ]; then
</span><span class='line'>          echo "must be command in profile"
</span><span class='line'>      else
</span><span class='line'>          echo $COMMAND &gt;&gt; $APPDIR/$APP/run
</span><span class='line'>      fi</span></code></pre></td></tr></table></div></figure>


<p>然后，在启动这个容器的地方，加上这个DOCKER_MEMORY参数限制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Service]
</span><span class='line'> TimeoutStartSec=900m
</span><span class='line'> ExecStartPre=-/usr/bin/fleetctl destroy $APP.service
</span><span class='line'> ExecStartPre=-/usr/bin/fleetctl destroy ${APP}_discovery.service
</span><span class='line'> ExecStartPre=/usr/bin/docker build -t $RIGISTRY/${APP}_image $APPDIR/$APP
</span><span class='line'>
</span><span class='line'> ExecStartPre=-/usr/bin/docker stop $APP
</span><span class='line'> ExecStartPre=-/usr/bin/docker rm $APP
</span><span class='line'> ExecStartPre=-/usr/bin/docker pull $RIGISTRY/${APP}_image
</span><span class='line'> ExecStart=/usr/bin/docker run --rm -P --name $APP $RIGISTRY/${APP}_image
</span><span class='line'> ExecStart=/usr/bin/docker run -P $DOCKER_MEMORY --name $APP $RIGISTRY/${APP}_image
</span><span class='line'> ExecStop=/usr/bin/docker stop $APP
</span><span class='line'> ExecStopPost=-/usr/bin/docker rm $APP</span></code></pre></td></tr></table></div></figure>


<p>这里可以看到，有个TimeoutStartSec这个参数，这个是用来等待的。可以看到我们这个service中，有个docker pull的命令，大家都知道，这个东西是非常耗时的，而fleet在启动service的时候，如果超过了特定的时间，就会被认为是应用超时，就会被停掉，所以，我们这里设置了一个大的时间进行等待。
ok，特定需求搞定了，然后我觉得，我们可以做的更好。除了Memory，我们完全可以再弄点别的参数设置上去。那么，我们之前那种通过grep查找的方式，就感觉太low了。这样，就会好很多。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> while read line; do
</span><span class='line'>      key=$(echo $line | cut -f 1 -d ' ')
</span><span class='line'>      str=""
</span><span class='line'>      value=$(echo ${line/$key/$str})
</span><span class='line'>      case $key in
</span><span class='line'>          memory:)
</span><span class='line'>              MEMORY=$(echo $line | awk '{ print $2 }')
</span><span class='line'>              DOCKER_MEMORY="-m $MEMORY"
</span><span class='line'>          ;;
</span><span class='line'>          command:)
</span><span class='line'>              echo $value &gt;&gt; $APPDIR/$APP/run
</span><span class='line'>          ;;
</span><span class='line'>          *)
</span><span class='line'>              echo "other settings"
</span><span class='line'>      esac
</span><span class='line'>  done &lt; $APPDIR/$APP/profile</span></code></pre></td></tr></table></div></figure>


<p>我们一行一行读，假如我们有新的需求，需要加入新的配置设置，就直接加进去，这样就感觉正规多了。至于DOCKER_MEMORY，这种东西，以后会变成DOCKER_SETTING，然后，有写的配置信息，直接接到后面就可以了。
我是一个天才，啊哈哈！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 5----maven规范和自发现服务]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-5/"/>
    <updated>2015-06-03T08:34:07+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-5</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>nap在对应用进行部署时，应该有一个判断机制，如果这个应用已经是最新的了，那么我们就直接返回最新的结果就可以了，不需要重新部署。而且我们的nap到现在为止，都是只完成了对Dockerfile应用的简单支持，简单一些，我们可以实现maven应用的支持。下面，我们就上面两个问题，进行简单介绍。</p>

<!--more-->


<h3>自发现服务</h3>

<p>如果我们在客户端git push的时候，如果这个应用已经部署好了，并且，部署的应用是最新的版本，我们是不需要再次部署的，直接返回部署好的应用的ip地址和端口就可以了。那么，是怎么做到的呢？我们的想法是，首先，在我们push之后，我们要在某一个地方部署，在部署的时候，肯定要先把应用git clone下来，那么我们假如之前已经部署过了，那么这个地方肯定就已经有了这个应用的代码，然后我们在这个文件夹下，git pull一下，如果提示，已经不是最新版本的应用，那么我们就重新部署。假如已经是最新的应用文件，那么接下来，我们就继续判断这个应用是否已经正确部署，如果是的，就返回正确部署的应用的ip和端口号，如果没有，就重新部署。关于如何返回正确的端口号和ip信息，因为我们在每次部署后都是把部署好的应用的ip和端口号写到etcd键值对服务中，只要去里面去读就可以了。代码如下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if [ -d $APPDIR/$APP ]; then
</span><span class='line'>  cd $APPDIR/$APP
</span><span class='line'>  update_new=$(git pull)
</span><span class='line'>  cd  
</span><span class='line'>  if [ "$update_new" = "Already up-to-date." ]; then
</span><span class='line'>      if [ $(etcdctl get /services/coreos1/$APP) ]; then
</span><span class='line'>          ipport_etcd=$(etcdctl get /services/coreos1/$APP)
</span><span class='line'>          exit
</span><span class='line'>      elif [ $(etcdctl get /services/coreos2/$APP) ]; then
</span><span class='line'>          ipport_etcd=$(etcdctl get /services/coreos2/$APP)
</span><span class='line'>                        exit
</span><span class='line'>      elif [ $(etcdctl get /services/coreos3/$APP) ]; then
</span><span class='line'>          ipport_etcd=$(etcdctl get /services/coreos3/$APP)
</span><span class='line'>                        exit
</span><span class='line'>        else
</span><span class='line'>          sudo rm -r $APPDIR/$APP
</span><span class='line'>            mkdir $APPDIR/$APP
</span><span class='line'>            git clone $GITDIR/$APP $APPDIR/$APP
</span><span class='line'>      fi
</span><span class='line'>  else
</span><span class='line'>      sudo rm -r $APPDIR/$APP
</span><span class='line'>      mkdir $ADDDIR/$APP
</span><span class='line'>      git clone $GITDIR/$APP $APPDIR/$APP
</span><span class='line'>  fi
</span><span class='line'>else
</span><span class='line'>  mkdir $APPDIR/$APP
</span><span class='line'>  git clone $GITDIR/$APP $APPDIR/$APP
</span><span class='line'>fi
</span></code></pre></td></tr></table></div></figure>


<p>也许你会很奇怪，为什么在判断应用已经是最新的，但是没有正确部署的时候，为什么要先把应用文件删除之后重新下载进行部署呢？这就是我们之后要实现的，支持maven规范的应用的支持了。</p>

<h3>支持maven规范的paas</h3>

<p>maven是一个很流行的一种版本规范吧，用我导师的话就是，“很简单的”，确实，如果只是想知道怎么用，还是很简单的，可以看看<a href="https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">这里</a>，一个5分钟的tutorial，大概就是一个应用分为以下几个文件夹。
- src 源代码，程序的源代码都是写在这里面的。
- pom.xml 一个文件，里面是关于你的这个应用所依赖的环境的描述，当然，你的依赖环境的描述要按照他的要求和规范写。
- profile 一个文件，这个是一个执行命令，是你程序的入口。就是maven在打包好你的应用之后，会去执行这个命令。</p>

<p>我的想法也很简单。首先，我们先制作一个支持maven的基础镜像。其实这个基础镜像只要在ubuntu的基础镜像上加两个东西就可以了。第一个是java环境，这个不用说也知道，如果没有java环境，maven都装不了。第二个也就是maven了，关于制作基础镜像的过程我们这里就不在描述了，没什么难点，唯一的难点就是我基础文档没有看好，没有充分利用ENV这个dockerfile的参数，浪费了一些时间。
有了maven的基础镜像之后，接下来就是把客户的程序拷贝进去，注意，不要用<code>COPY * /app</code>这种方式，这种方式会拷贝当前目录下所有的文件，和文件夹内部的内容，我没有更好的解决这个问题的办法，因为他的机制就是不支持，我的解决办法就是我指定要拷贝的文件名，这种拷贝方式是拷贝的文件。当拷贝进去之后，就可以用mvn package打包文件，然后把profile写到Dockerfile的Entrypoint里面，这样，新的Dockerfile就产生了，就可以部署了。代码如下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if [ ! -f $APPDIR/$APP/Dockerfile ]; then
</span><span class='line'>  if [ -f $APPDIR/$APP/pom.xml ]; then
</span><span class='line'>      sudo touch $APPDIR/$APP/Dockerfile
</span><span class='line'>      sudo chmod o+w $APPDIR/$APP/Dockerfile
</span><span class='line'>      cat &gt; $APPDIR/$APP/Dockerfile &lt;&lt;EOF
</span><span class='line'>FROM docker.iwanna.xyz:5000/hmonkey/maven
</span><span class='line'>MAINTAINER hmonkey &lt;5681713@qq.com&gt;
</span><span class='line'>
</span><span class='line'>COPY pom.xml /app/pom.xml
</span><span class='line'>COPY src /app/src
</span><span class='line'>COPY profile /app/profile
</span><span class='line'>COPY data /app/data
</span><span class='line'>WORKDIR /app
</span><span class='line'>RUN mvn package
</span><span class='line'>ENTRYPOINT ["sh", "/app/profile"]
</span><span class='line'>EOF
</span><span class='line'>  else 
</span><span class='line'>      echo "anything else"
</span><span class='line'>  fi
</span><span class='line'>fi</span></code></pre></td></tr></table></div></figure>


<p>这也回答了上面，为什么要rm文件夹的问题，因为如果不rm，maven的Dockerfile会在第一次执行之后添加进去，如果你不rm掉，即使你有更新，也不会判断这是一个maven程序，因为这里面有了Dockerfile。还有就是我觉得maven这个东西这样做是不够的，或者我这种实现方式的问题，不能COPY所有的事情，所以我们这里加了一个data文件夹，专门用来存储一些数据。这可以说是我的一种机制。
还有一个问题就是，如何返回数据值的问题，你这个应用总有一个计算结果，那么这个结果放在哪里呢？怎么返回给用户呢？这里还没有想清楚，后面我们会具体思考。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 4----fleet集群部署]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-4/"/>
    <updated>2015-05-28T07:53:03+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-4</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>我们之后可能会遇到这个问题。部署成功了一个web应用，我们需要给这个应用注册一个web地址，并且返回给用户，那么，如何得到这个应用的ip地址，端口号等信息呢？在fleet的机制中，有个discovery机制，这个机制就很好的完成了这个工作，其主要工作原理就是，运行一个discovery service，通过不断轮询对应的service有没有启动起来，如果启动起来了，就把其端口号和ip地址等信息写入到etcd中去，当需要的时候，再从etcd中取。下面，我们来简单介绍一些这些在nap中的代码实现。</p>

<!--more-->


<h3>fleet 集群部署</h3>

<p>前面已经基本把dockerfile转换为了fleet的unit，我们是通过两个unit的形式，一个用来build和push基本image，一个用来pull和run这个image。
那么，既然有了unit，其实跑起来就很容易了，用fleetctl start unit.service就可以了，但是，跑起来之后，我们发现一个比较严肃的问题，我们无法返回跑起来的容器的端口号！fleet有个命令行工具，叫做fleetctl，通过fleetctl &ndash;help查看所有的命令。
<img src="http://i1066.photobucket.com/albums/u407/5681713/iwanna/fleetctl--help_zpsmnhrgbo8.png" alt="fleetctl --help" />
我们发现，我们只能找到fleetctl list-units这个命令来返回有关已经部署的应用的信息。然而，这里面只能看到跑着的应用的ip地址，并没有更加详细的信息，比如端口号。
<img src="http://i1066.photobucket.com/albums/u407/5681713/iwanna/list-units_zps1hn0chr3.png" alt="list-units" />
但是，这种问题怎么会难得到我呢？我想了想，想到了自认为一个很天才的想法。我每次通过fleetctl部署应用的时候，我不知道他会部署到哪里，所以再去寻找他，返回他的端口号是非常麻烦的，但是，我可以在部署的时候，就找到部署的应用的ip和端口号，然后把这些信息写到etcd里面，反正etcd是一个用来存储键值对的。这样，我如果想知道这个应用部署在哪个机器上，只要去etcd里面去查，因为etcd是全局共享的嘛，这就简单了。果然，我是个天才。然后，由于我在后面遇到了一个问题，发现相同的程序，部署的时候，有时候会写入etcd，有的时候不会写入，这个问题就比较烦人了，也比较容易想到为什么，这样肯定就是因为部署的时候，有的时候部署的慢，还没有部署完就去写，肯定没写成功，部署快的时候就可以写成功。我去查这个问题的时候，无意间浏览到官网的文档，发现官网其实早就已经提供了一个机制，用来实现我刚刚的想法，是使用了BindsTo和MachineOf这两个东西。具体我们下面来说说看。
思路和我的思路是一样的，不同之处在于，官网的这个机制，并不是在部署应用的时候就去写etcd，而是在部署完成后，通过MachineOf，找到部署应用的那个机器，然后再开启一个unit，这个unit是干嘛的？就是用来写etcd的，我之前说不知道应用什么时候部署成功，那么官网就是用一个无尽循环的方式，一直不停地去读这个应用，然后去写etcd的方式完成的。BindsTo的思想就是把这个写etcd的unit和部署应用的unit绑在一起，后面那个unit stop的时候，前面那个也stop，但是反过来就不成立了。
具体代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#部署应用的unit
</span><span class='line'>[Unit]
</span><span class='line'>Description=${APP}
</span><span class='line'>Requires=docker.service
</span><span class='line'>After=docker.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>TimeoutStartSec=0
</span><span class='line'>ExecStartPre=-/usr/bin/docker pull $RIGISTRY/${APP}_image
</span><span class='line'>ExecStart=/usr/bin/docker run --rm -P --name $APP $RIGISTRY/${APP}_image
</span><span class='line'>ExecStop=/usr/bin/docker stop $APP
</span><span class='line'>
</span><span class='line'>[X-Fleet]
</span><span class='line'>MachineID=6182ab18ffa44912a1e773914936105f
</span><span class='line'>
</span><span class='line'>#写etcd的unit
</span><span class='line'>[Unit]
</span><span class='line'>Description=${APP}_discovery
</span><span class='line'>BindsTo=$APP.service
</span><span class='line'>After=$APP.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>ExecStart=/bin/sh -c "while true; do appport=\$(docker inspect --format='' $APP); etcdctl set /services/$APP/\"%H\" '{\"host\": \"%H\", \"port\": '\$appport'}' --ttl 60; sleep 45; done"
</span><span class='line'>ExecStop=/usr/bin/etcdctl rm /services/$APP/"%H"
</span><span class='line'>
</span><span class='line'>[X-Fleet]
</span><span class='line'>MachineOf=$APP.service
</span><span class='line'>
</span><span class='line'>#先后运行
</span><span class='line'>fleetctl submit $WORKDIR/$APP.service $WORKDIR/${APP}_discovery.service
</span><span class='line'>fleetctl start $WORKDIR/$APP.service &gt; /dev/null
</span><span class='line'>fleetctl start $WORKDIR/${APP}_discovery.service &gt; /dev/null
</span><span class='line'>
</span><span class='line'>#运行一段时间后，查看是不是写成功了。
</span><span class='line'>sleep 30
</span><span class='line'>hello=$(etcdctl ls /services/$APP)
</span><span class='line'>world=$(etcdctl get $hello)
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 3----整体流程]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-3/"/>
    <updated>2015-05-24T12:20:17+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-3</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>有了上一篇关于客户端和服务器端的设计介绍，我们就可以简单地把这两者联系起来，构成一个paas平台的小demo。我们这里通过对最简单的应用类型，有dockerfile的应用，做一次完整的，从push到解释为systemd的service，到最终运行在单机服务器上的过程，首先跑通这个流程，然后再在这个基础上，增加新的应用类型，和晚上操作。</p>

<!--more-->


<h3>整体流程</h3>

<p>客户端，用户创建一个新的git，或者修改一个已经存在的git repository，然后git remote add iwanna iwanna@ip:appname，然后，git push iwanna master。实际上执行了ssh iwanna@ip git-receive-pack &lsquo;app&rsquo;
这个时候，触发服务器端，用户iwanna用户路径下的.ssh/authorized_keys，找里面对应的rsa key，这个时候，我们要修改其中的rsa key，在前面添加ssh forced command，使得他能够进入我们希望的进入点。比如command=&ldquo;/home/iwanna/iwanna $SSH_ORIGINAL_COMMAND&rdquo; rsa-key。这样就去找/home/iwanna/iwanna这个脚本，执行这个脚本。那么这个脚本要写什么事情呢？
首先，我们要明确几个设计理念。第一，我们要把git server作为单独的一个容器，用户push的时候，就是push到了这个git server里面，我们要部署的时候，再git clone到一个容器里面，在这里面部署。其次，我们要有独立的registry，这个registry就是专门用来存储我们build的镜像的。最后，要注意我们是在多个host主机下做的这件事情，关于信息的返回就要多加注意。
我还没有思考好怎么把git server放在一个容器里面，所以，我们这里就先部署在coreos里面来先做个试验，想好了，后面会补上这一部分。</p>

<p>首先，我们在所在的host的coreos系统里面看看有没有用来放git repository的路径和app的路径，如果没有，先建好。这种情况在部署第一个应用的时候会出现，在以后弄好一键式部署的时候，这一步可以放在部署阶段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#apps in /home/iwanna/apps and git repository in /home/iwanna/gits
</span><span class='line'>[ -d /home/iwanna/gits ] || (mkdir /home/iwanna/gits)
</span><span class='line'>[ -d /home/iwanna/apps ] || (mkdir /home/iwanna/apps)
</span><span class='line'>GITDIR=/home/iwanna/gits
</span><span class='line'>APPDIR=/home/iwanna/apps
</span><span class='line'>REGISTRY=docker.iwanna.xyz:5000/iwanna</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们要先把git push的时候，git server要做的事情做了。如果本来有这个repository，那么就直接用git-shell来做，如果没有，别忘了先git init &ndash;bare他。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>args=$*
</span><span class='line'>#judge if app git exist, if not git init or nothing
</span><span class='line'>[ -d $GITDIR/$APP ] || (git init --bare $GITDIR/$APP &gt; /dev/null)
</span><span class='line'>git-shell -c "$args"</span></code></pre></td></tr></table></div></figure>


<p>继续。已经做完了git server应该做的事情。接下来就是部署一个应用了。理论上应该也用一个容器来部署一个应用，但是，我也没有想好应该怎么做，所以，我们先用coreos系统来操纵部署一个应用。
首先判断在coreos系统中专门用来部署应用的路径$APPDIR里面有没有部署过这个应用，如果没有，就简单了，首先创造这个路径，然后，把git server上的对应app clone下来，这样就把应用clone下来了。如果已经存在了，那么就要考虑两种情况，首先，判断这次和上次部署的有没有区别，如果本来就是最新的，那么就不用重新部署了，直接返回原来的应用的ip和端口就可以了。如果有区别，那么就删除原来的应用，重新clone新的应用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#judge if app exist, if not clone, or how?
</span><span class='line'>if [ !-d $APPDIR/$APP ]; then
</span><span class='line'>  mkdir $APPDIR/$APP
</span><span class='line'>  git clone $GITDIR/$APP $APPDIR/$APP
</span><span class='line'>else
</span><span class='line'>  sudo rm -r $APPDIR/$APP
</span><span class='line'>  mkdir $APPDIR/$APP
</span><span class='line'>  git clone $GITDIR/$APP $APPDIR/$APP
</span><span class='line'>fi</span></code></pre></td></tr></table></div></figure>


<p>attention: 关于如何判断是否为最新，这里还没有去查，等查好了，这里会修改。
已经把应用的文件下载下来了，接下来的就是部署它了。我们这里的协同语言还比较简单，我们就只是部署用Dockerfile写的应用。基本思路应该是简单的，把Dockerfile转变为fleetctl可以理解的方式，然后用fleetctl部署，返回部署应用的机器的ip和端口号即可。关于解读Dockerfile中某些特殊的命令，我们之后再详细解释。</p>

<p>coreos中，一般把要部署的应用放在/etc/systemd/systemd中，同样的，我们也把服务写在这个目录下。我们这里不考虑Dockerfile中的命令，只是部署一个最简单的应用，那么，Unit和Install中应该就是常规的标志，Service中，只要部署这个应用就可以了。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>WORKDIR=/etc/systemd/system
</span><span class='line'>sudo touch $WORKDIR/$APP.service
</span><span class='line'>SERVICE="$WORKDIR/$APP.service"
</span><span class='line'>sudo chmod o+w $SERVICE
</span><span class='line'>cat &gt; $SERVICE &lt;&lt;EOF
</span><span class='line'>[Unit]
</span><span class='line'>Description=$APP
</span><span class='line'>Requires=docker.service
</span><span class='line'>After=docker.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>ExecStartPre=/usr/bin/docker build -t $APP /home/core/gitrepository/$APP
</span><span class='line'>ExecStartPre=/usr/bin/docker stop $APP
</span><span class='line'>ExecStartPre=/usr/bin/docker rm $APP
</span><span class='line'>ExecStart=/usr/bin/docker run -d -P --name $APP $APP
</span><span class='line'>
</span><span class='line'>[Install]
</span><span class='line'>WantedBy=multi-user.target
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>


<p>但是，这个时候，实际上我们自觉回避了两个内容。
第一，是build和run的时机。我们这里实际上是在单host上测试的，所以，这里在同一个service中既有build，也有run。实际上，如果是多host，那么就需要了。我们应该是单独一个service来build，和push到registry，然后有另一个service，用来run。所以，应该是下面这样。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>WORKDIR=/etc/systemd/system
</span><span class='line'>sudo touch $WORKDIR/BUILD_${APP}.service
</span><span class='line'>BUILD_SERVICE="$WORKDIR/BUILD_${APP}.service"
</span><span class='line'>sudo chmod o+w $BUILD_SERVICE
</span><span class='line'>cat &gt; $BUILD_SERVICE &lt;&lt;EOF
</span><span class='line'>[Unit]
</span><span class='line'>Description=${APP}_build
</span><span class='line'>Requires=docker.service
</span><span class='line'>After=docker.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>ExecStartPre=-/usr/bin/docker stop $APP
</span><span class='line'>ExecStartPre=-/usr/bin/docker rm $APP
</span><span class='line'>ExecStartPre=-/usr/bin/docker rmi ${APP}_image
</span><span class='line'>ExecStartPre=/usr/bin/docker build -t $RIGISTRY/${APP}_image $APPDIR/$APP
</span><span class='line'>ExecStart=/usr/bin/docker push $RIGISTRY/${APP}_image
</span><span class='line'>
</span><span class='line'>[Install]
</span><span class='line'>WantedBy=multi-user.target
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>


<p>attention:这里上面的ExecStartPre里面的停止应用，删除应用，都应该是fleetctl的操作，但是我们这里还没有经过测试，所以我们这里先用docker的代替一下，后面测试通过了，这里会进行修改。</p>

<p>然后跑应用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo touch $WORKDIR/$APP.service
</span><span class='line'>SERVICE="$WORKDIR/$APP.service"
</span><span class='line'>sudo chmod o+w $SERVICE
</span><span class='line'>cat &gt; $SERVICE &lt;&lt;EOF
</span><span class='line'>[Unit]
</span><span class='line'>Description=${APP}
</span><span class='line'>Requires=docker.service
</span><span class='line'>After=docker.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>ExecStartPre=/usr/bin/docker pull $RIGISTRY/${APP}_image
</span><span class='line'>ExecStart=/usr/bin/docker run -d -P --name $APP $RIGISTRY/${APP}_image
</span><span class='line'>
</span><span class='line'>[Install]
</span><span class='line'>WantedBy=multi-user.target
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>


<p>第二个忽略的问题就是关于Dockerfile中命令的解读，这个也没想清楚，后面补上。</p>

<p>然后跑起来应用。这里应该是用fleetctl跑应用，也是没有测试怎么返回跑的应用的ip和端口，后面测试了再补上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo systemctl enable /etc/systemd/system/$APP.service
</span><span class='line'>sudo systemctl daemon-reload
</span><span class='line'>sudo systemctl start $APP.service
</span><span class='line'>id=$(sudo docker ps -lq)
</span><span class='line'>port=$(docker inspect --format='' $id)
</span><span class='line'>ip=$(cat /home/core/HOST)
</span><span class='line'>echo $ip:$port</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 2----分解客户端和服务器端]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-2/"/>
    <updated>2015-05-18T16:20:46+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-2</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>前面一片文章我们主要介绍了我们的paas平台nap所基于的技术基础，这篇文章，我们首先介绍一下nap的整体思路，然后通过从客户端和服务器端的一些设计，一步一步地来了解如何设计一个完整的paas平台。</p>

<!--more-->


<h3>客户端</h3>

<p>不着急，我们一步一步来。我们先来大体理一下思路，客户端git push，然后，服务器端接受到代码，然后部署，然后返回部署是否成功，ip地址和端口号是多少等，在运行的阶段，可能还会有健康检查，重新部署之类的东西。好了，大体思路有了，我们一点一点来实现。</p>

<p>首先来个简单的。git push的时候，服务器端调用服务器上的一个脚本。这里用到的知识就是我们之前说过的ssh forced command，可以看看之前写的blog，<a href="http://monkey-h.github.io/blog/dokkudao-di-gan-liao-shi-yao/">dokku源码解读1</a>.
git我们之前也介绍过了，git就是一个版本控制工具，而具备远程存储能力的git，也只不过是把本地的git repository移到远程服务器而已。而且我们知道，每次git push的时候，都会执行<code>ssh git@git.com git-receive-pack 'mygit.git'</code>，实际上也是执行了ssh命令。好了，第一步，我们就实现在客户端git push的时候，远程服务器通过本地的脚本，执行echo hello就可以了。</p>

<p>客户端不需要任何修改，在服务器端，修改对应客户端的rsa key。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh core@ip //我们之前已经装好了coreos集群，用户名就是core。
</span><span class='line'>vim ~/.ssh/authorized_keys //寻找自己的rsa key的位置。
</span><span class='line'>command="/home/core/script $SSH_ORIGINAL_COMMAND" ssh-rsa xxxxxx //在前面添加自己的ssh forced command，需要注意的是后面的那个参数，那个参数是系统自动填写的参数，假如客户端执行git push的时候，应该就是git-receive-pack 'mygit.git'。保存退出。
</span><span class='line'>cd /home/core
</span><span class='line'>touch script //我们在rsa key里加的command说使用了script脚本，当然要有这个脚本。
</span><span class='line'>vim script //编辑这个脚本，在这里面写下下面这两行命令。
</span><span class='line'>set -x   //第一行的意思是debug模式，这样我们才可以看到这个脚本执行到哪里了，有没有成功。
</span><span class='line'>echo hello</span></code></pre></td></tr></table></div></figure>


<p>好了，可以了，我们尝试一下。在客户端</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir hello //建立一个git文件夹，并初始化
</span><span class='line'>cd hello
</span><span class='line'>git init
</span><span class='line'>git remote add mypaas core@ip //添加远程仓库
</span><span class='line'>touch hello
</span><span class='line'>git commit -am "hello" //当仓库为空的时候，是不能push的时候。
</span><span class='line'>git push mypaas master //push</span></code></pre></td></tr></table></div></figure>


<p>这个时候，应该可以看到输出了hello。</p>

<p>attention：
需要注意的是，如果我们修改了rsa key前面的command，那么我们ssh进去服务器的时候，会执行command，而不会进去了，一定要注意这种情况，有可能导致你永远进不去系统。解决办法是你在coreos系统中重新建立一个用户，修改这个用户的rsa key前的command，而保存一个始终可以ssh进去的用户。但是我不知道coreos怎么给新用户赋予可以sudo权限，没有找到visudo，或者sudoers，等我知道了就在这里补充一下。所以我现在就保持有一个ssh到coreos的终端，或者每次下班了之后，就把rsa key中的command去除，下次尝试的时候再加进去。</p>

<p>coreos添加新用户，并赋予sudo权限。
添加user的时候，不要用常规的linux方法，采用修改cloud-config文件的方式。cloud-config文件在/var/lib/coreos-install/user_data里面。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- name: test
</span><span class='line'>    ssh-authorized-keys:
</span><span class='line'>      - ssh-rsa xxx
</span><span class='line'>    groups:
</span><span class='line'>      - sudo
</span><span class='line'>      - docker</span></code></pre></td></tr></table></div></figure>


<p>在users里面添加这样一个新的用户，group里面的sudo，就是赋予sudo权限。具体可以看官方说明。然后使得新配置生效。
<code>sudo coreos-cloudinit --from-file /var/lib/coreos-install/user_data</code></p>

<h3>服务器</h3>

<p>还是一步一步来，我们把困难的任务分解来看。我们这里就做一个脚本，这个脚本是干什么的呢，就是读取一个文件夹里的Dockerfile，然后生成systemd可以解释的文件，然后执行他。至于这个Dockerfile怎么来的，先不考虑，我们就直接写一个Dockerfile，后来的时候应该是git push上来的。脚本代码应该是这样。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\#!/bin/bash
</span><span class='line'>set -x
</span><span class='line'>
</span><span class='line'>WORKDIR=/etc/systemd/system
</span><span class='line'>APP="hello"
</span><span class='line'>sudo touch $WORKDIR/$APP.service
</span><span class='line'>SERVICE="$WORKDIR/$APP.service"
</span><span class='line'>sudo chmod o+w $SERVICE
</span><span class='line'>cat &gt; $SERVICE &lt;&lt;EOF
</span><span class='line'>[Unit]
</span><span class='line'>Description=$APP
</span><span class='line'>Requires=docker.service
</span><span class='line'>After=docker.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>ExecStartPre=/usr/bin/docker build -t $APP /home/core/$APP
</span><span class='line'>ExecStartPre=/usr/bin/docker stop $APP
</span><span class='line'>ExecStartPre=/usr/bin/docker rm $APP
</span><span class='line'>ExecStart=/usr/bin/docker run -d -P --name $APP $APP
</span><span class='line'>
</span><span class='line'>[Install]
</span><span class='line'>WantedBy=multi-user.target
</span><span class='line'>EOF
</span><span class='line'>sudo systemctl enable /etc/systemd/system/$APP.service
</span><span class='line'>sudo systemctl daemon-reload
</span><span class='line'>sudo systemctl start $APP.service</span></code></pre></td></tr></table></div></figure>


<p>简单吧，读取/home/core/$APP路径下的Dockerfile，然后打包成一个image，然后删除可能存在的，然后运行。</p>

<p>后面我们将会讲解怎么把这两个简单的步骤组合起来，组合起来之后，就是一个简单的，具备paas平台过程的paas平台了，虽然还有很多需要修改，补充，完善的地方。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计自己的paas平台nap 1----背景知识]]></title>
    <link href="http://monkey-h.github.io/blog/my-paas-1/"/>
    <updated>2015-05-18T14:49:52+08:00</updated>
    <id>http://monkey-h.github.io/blog/my-paas-1</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>在理解了dokku，dokku-alt的基础上，我们设计自己的paas平台。我们的终极目标是在一个集群环境中设计一个paas平台，dokku只是单机环境下，为了我们的终极目标，我们最终选择的paas的底层平台是coreos集群环境。这几篇blog只是我们不断进行尝试的日志，并不是一个完整的教程，等我们最终搭建好了，可能会写一个完整的教程，但那都是后话。</p>

<!--more-->


<h3>coreos</h3>

<p>在<a href="coreos.com">coreos官网上</a>，coreos的副标题就是Linux for massive server deployments。coreos简单来说，就是为云环境而生的操作系统，真正的云操作系统。它具有很多操作系统没有的优点，它最初的设计源自于google的chromeos，对系统结构重新设计，剔除了任何不必要的软件和服务。适合集群环境，而不是传统的服务器操作系统。
没有提供包管理工具，通过容器化，向应用程序提供运算环境。应用程序之间共享系统内核和资源，但是彼此之间又互不可见。应用程序将不会再被直接安装到操作系统中，而是通过 Docker 运行在容器中。这种方式使得操作系统、应用程序及运行环境之间的耦合度大大降低。
采用双系统分区设计。ChromeOS最大的优点。两个分区分别被设置成主动模式和被动模式并在系统运行期间各司其职。主动分区负责系统运行，被动分区负责系统升级。一旦新版本的操作系统被发布，一个完整的系统文件将被下载至被动分区，并在系统下一次重启时从新版本分区启动，原来的被动分区将切换为主动分区，而之前的主动分区则被切换为被动分区，两个分区扮演的角色将相互对调。同时在系统运行期间系统分区被设置成只读状态，这样也确保了 CoreOS 的安全性。CoreOS 的升级过程在默认条件下将自动完成，并且通过 cgroup 对升级过程中使用到的网络和磁盘资源进行限制，将系统升级所带来的影响降至最低。
使用Systemd取代SysV作为系统和服务的管理工具。具备优秀的并行化处理能力，按需启动等特点。</p>

<p>既然说到coreos是最好的云操作系统，那么coreos和集群就联系的十分紧密了。coreos集群中最重要的是三个概念。docker，fleet，etcd。</p>

<p>docker技术我们这里就不在介绍了，docker技术也是我们研究的主题，如果docker技术都不懂，那么你根本不会看这篇blog。</p>

<p>其次是fleet。fleet 是一个通过 Systemd对CoreOS 集群中进行控制和管理的工具。每个 fleet agent 之间通过 etcd 服务来注册和同步数据。fleet 提供的功能非常丰富，包括查看集群中服务器的状态、启动或终止 Docker container、读取日志内容等，某个服务器脱离集群，其上面的所有服务都会转移到别的服务器上。包括部署高可用的服务等。fleet提供了很多好用的api接口，在后面我们会详细介绍。
<img src="http://i1066.photobucket.com/albums/u407/5681713/coreos/fleet_zps3dvxl6hl.png" alt="" /></p>

<p>最后是etcd。etcd技术是coreos的骨架。etcd 是一个分布式 key/value 存储服务，CoreOS 集群中的程序和服务可以通过 etcd 共享信息或做服务发现 。etcd 基于 raft 一致性算法：通过选举形式在服务器之中选举 Lead 来同步数据，并以此确保集群之内信息始终一致和可用
<img src="http://i1066.photobucket.com/albums/u407/5681713/coreos/_zpscrifu3cf.png" alt="" /></p>

<h3>systemd</h3>

<p>在前面提到过，coreos是通过systemd来系统和服务的管理工具，同样的fleet也是通过systemd，看来，systemd的一些基本语法也是我们要了解的内容。</p>

<ul>
<li>sudo systemctl status xx.service 查看某个服务的状态。</li>
<li>sudo systemctl start xx.service</li>
<li>sudo systemctl stop xx.service</li>
<li>sudo systemctl kill xx.service</li>
<li>sudo systemctl restart xx.service</li>
<li>sudo systemctl daemon-reload 如果重启一个修改了service文件的服务，你必须reload service文件</li>
</ul>


<p>systemd由两个基本概念组成，unit和target。unit是一个配置文件，用来描述想要跑的进程的一些参数。target是一个grouping mechanism，用来允许systemd在同一时间起多个进程。systemd是coreos上启动的第一个进程。systemd进程读取不同的target，运行这些进程。每一个target一般是对unit文件的一个symlinks的集合，当运行systemctl enable foo.service 的时候，就会创建一个指向这个unit文件的symlinks，在multi-user.target.wants中。</p>

<p>在coreos中，unit files一般位于/etc/systemd/system中，这个文件系统是可读写的。</p>

<p>看个基本的例子。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Unit]
</span><span class='line'>Description=MyApp
</span><span class='line'>After=docker.service
</span><span class='line'>Requires=docker.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>TimeoutStartSec=0
</span><span class='line'>ExecStartPre=-/usr/bin/docker kill busybox1
</span><span class='line'>ExecStartPre=-/usr/bin/docker rm busybox1
</span><span class='line'>ExecStartPre=/usr/bin/docker pull busybox
</span><span class='line'>ExecStart=/usr/bin/docker run --name busybox1 busybox /bin/sh -c "while true; do echo Hello World; sleep 1; done"
</span><span class='line'>
</span><span class='line'>[Install]
</span><span class='line'>WantedBy=multi-user.target</span></code></pre></td></tr></table></div></figure>


<p>after和requires，这个基本定义了运行这个程序在哪个区间里，上面的例子就是说，只有在docker.service运行起来之后，才可以运行这个东西。
execstart 在执行这个unit的时候，要干什么事情。这个进程的pid就是systemd监控的用来判断进程是否挂掉的进程。不要跑container用-d参数，这个参数会阻止container用这个pid的子进程来运行。这样systemd会认为这个进程已经退出了，那么这个unit也会被停止。
wantedby指出这个unit是哪个targt的一部分。</p>

<ul>
<li><p>sudo systemctl enable /etc/systemd/system/hello.service会创建一个symlink。</p></li>
<li><p>sudo systemctl start hello.service</p></li>
<li><p>journalctl -f -u hello.service会读取hello.service的输出。</p></li>
<li><p>ExecStartPre 执行execstart之前要执行的命令。</p></li>
<li><p>execstart 这个unit的主要的执行命令。</p></li>
<li><p>execstartpost 当execstart执行结束，执行的命令。</p></li>
<li><p>execreload 当执行systemctl reload xx.service的时候，会执行的命令。</p></li>
<li><p>execstop 当unit被认为失败，或者执行systemctl stop xx.service的时候，执行的命令。</p></li>
<li><p>execstoppost 当execstop执行完成后，执行的操作。</p></li>
<li><p>RestartSec 当重启一个服务的时候，要睡眠多少秒，当预防失败的服务没100ms自己尝试restart的情况。</p></li>
<li><p>=-是忽视这条命令产生的错误。当我们删除一个不存在的container的时候，会报没有这个container错误，但是我们只是保险起见，所以这个并不能称为错误。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图的三角形计数]]></title>
    <link href="http://monkey-h.github.io/blog/hadoop-4/"/>
    <updated>2015-05-08T09:05:02+08:00</updated>
    <id>http://monkey-h.github.io/blog/hadoop-4</id>
    <content type="html"><![CDATA[<h3>实验背景</h3>

<p>图的三角形计数问题是一个基本的图计算问题,是很多复杂网络分析(比如社 交网络分析)的基础。目前图的三角形计数问题已经成为了 Spark 系统中 GraphX 图计算库 所提供的一个算法级API。本次实验任务就是要在Hadoop系统上实现Twitter社交网络图的 三角形计数任务。
换句话说，这TM是mapreduce课程的作业啊，不做也得做啊！！！</p>

<!--more-->


<h3>实验要求</h3>

<p>一个社交网络可以看做是一张图(离散数学中的图)。社交网络中的人对应于图的顶点;社 交网络中的人际关系对应于图中的边。在本次实验任务中,我们只考虑一种关系——用户之 间的关注关系。假设“王五”在 Twitter/微博中关注了“李四”,则在社交网络图中,有一条对 应的从“王五”指向“李四”的有向边。图 1 中展示了一个简单的社交网络图,人之间的关注关 系通过图中的有向边标识了出来。
<img src="" alt="graph" />
本次的实验任务就是在给定的社交网络图中,统计图中所有三角形的数量。
在统计前,需要先进行有向边到无向边的转换,依据如下逻辑转换:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IF ( A→B) OR (B→A) THEN A-B</span></code></pre></td></tr></table></div></figure>


<p>“A→B”表示从顶点 A 到顶点 B 有一条有向边。A-B 表示顶点 A 和顶点 B 之间有一条无向边。
一个示例见图 1,图 1 右侧的图就是左侧的图去除边方向后对应的无向图。 请在无向图上统计三角形的个数。在图 1 的例子中,一共有 3 个三角形。
+ 输入格式
输入数据仅一个文件。该文件由若干行组成,每一行由两个以空格分隔的整数组成:
A B
A,B 分别是两个顶点的 ID。这一行记录表示图中具有一条由 A 到 B 的有向边。整个图的结构由该文件唯一确定。
下面的框中是文件部分内容的示例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>87982906 17975898
</span><span class='line'>17809581 35664799
</span><span class='line'>524620711 270231980
</span><span class='line'>247583674 230498574
</span><span class='line'>348281617 255810948
</span><span class='line'>159294262 230766095
</span><span class='line'>14927205 5380672
</span><span class='line'>......</span></code></pre></td></tr></table></div></figure>


<ul>
<li>输出格式
请在报告中报告如下内容:
1.实验设计说明,包括主要设计思路、算法设计、程序和各个类的设计说明
2.最终统计出的三角形个数
3.程序运行和实验结果说明和分析
4.性能、扩展性等方面存在的不足和可能的改进之处
5.源程序,执行程序
6.在集群上运行 MapReduce 作业的截屏、JobTracker 上记录的截屏</li>
</ul>


<h3>实验思路</h3>

<p>基本思路很简单，假如我们找到了 A->B 和 A->C 两个边，那么，我们只要去找有没有B->C这条边就可以了。
详细来说，我们使用了三个map reduce过程来实现这个东西。
- 第一个map reduce
map用来调换顺序，意思就是，我们把 A->B 和 B->A 都变成 A->B，这样有什么好处呢？之前实验要求里也说了， A->B 和 B->A 这两条有向边应该化成一条无向边，这第一个map reduce就是做这个事情的。这里，把 A->B 作为key。
reduce过程是去重，就是假如有多个A->B，记做一个边，当然如果实验要求不同，可以不同。
- 第二个mapreduce
map过程是把key A->B 拆开，把A作为key，把B作为value。这里是干什么呢？这里就是要寻找了，我们要找到需要的边，也就是上面举例中的B->C边存在不存在。
reduce过程，对value进行处理。比如key为A，那么，其value应该是所有和A有边的点。假如B,C，那么我们就要把B->C作为新的key，其value我们用&amp;来代替，意思就是这是我们要找的边。另一方面，我们不能把原来的边直接删掉，因为我们还是要从这里面找边，那么，还要有A->B,A->C这样的key，其value我们用#来表示，代表这是存在的边。
- 第三个mapreduce
map过程没有做上面事情，就是把第二部reduce的数据重新传到第三步的reduce。
reduce就是比对。我们找到每个key后面的value中，有没有#，如果有，就说明存在这个边，然后把除了#之外的&amp;的个数进行统计，和就是我们所需要的个数。最后通过一个cleanup函数，打印最后的统计结果即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import java.io.IOException;
</span><span class='line'>import java.util.ArrayList;
</span><span class='line'>import java.util.StringTokenizer;
</span><span class='line'>
</span><span class='line'>import org.apache.hadoop.fs.Path;
</span><span class='line'>import org.apache.hadoop.io.LongWritable;
</span><span class='line'>import org.apache.hadoop.io.Text;
</span><span class='line'>import org.apache.hadoop.mapreduce.Job;
</span><span class='line'>import org.apache.hadoop.mapreduce.Mapper;
</span><span class='line'>import org.apache.hadoop.mapreduce.Reducer;
</span><span class='line'>import org.apache.hadoop.util.GenericOptionsParser;
</span><span class='line'>import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
</span><span class='line'>import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
</span><span class='line'>import org.apache.hadoop.conf.Configuration;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>public class triangle {
</span><span class='line'>  
</span><span class='line'>  public static class sortMapper extends Mapper&lt;Object, Text, Text, Text&gt;{
</span><span class='line'>      private Text a = new Text();
</span><span class='line'>      private Text b = new Text();
</span><span class='line'>      
</span><span class='line'>      public void map(Object key,Text value,Context context)throws IOException,InterruptedException {
</span><span class='line'>
</span><span class='line'>          StringTokenizer itr=new StringTokenizer(value.toString());
</span><span class='line'>          long first = Integer.parseInt(itr.nextToken());
</span><span class='line'>          long second = Integer.parseInt(itr.nextToken());
</span><span class='line'>          if (first &lt;= second){
</span><span class='line'>              a.set(first+"#"+second);
</span><span class='line'>              b.set("#");
</span><span class='line'>          }
</span><span class='line'>          else{
</span><span class='line'>              a.set(second+"#"+first);
</span><span class='line'>              b.set("#");
</span><span class='line'>          }
</span><span class='line'>          context.write(a, b);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  public static class sortReducer extends Reducer&lt;Text, Text, Text, Text&gt;{
</span><span class='line'>      private Text b = new Text();    
</span><span class='line'>      public void reduce(Text key,Iterable&lt;Text&gt; values,Context context)throws IOException,InterruptedException {
</span><span class='line'>          //Text b = new Text();
</span><span class='line'>          b.set("#");
</span><span class='line'>          context.write(key, b);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  public static class findMap extends Mapper&lt;LongWritable, Text, Text, Text&gt;{
</span><span class='line'>      public void map(LongWritable key, Text value, Context context)throws IOException,InterruptedException {
</span><span class='line'>          StringTokenizer itr=new StringTokenizer(value.toString());
</span><span class='line'>          String[] tokens = itr.nextToken().toString().split("#");
</span><span class='line'>          //String[] tokens = value.toString().split("#");
</span><span class='line'>          String a = tokens[0];
</span><span class='line'>          String b = tokens[1];
</span><span class='line'>          //System.out.println(a+"    "+b);
</span><span class='line'>          Text left = new Text();
</span><span class='line'>          Text right = new Text();
</span><span class='line'>          left.set(a+"");
</span><span class='line'>          right.set(b+"");
</span><span class='line'>          context.write(left, right);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  public static class findReducer extends Reducer&lt;Text, Text, Text, Text&gt;{
</span><span class='line'>      
</span><span class='line'>       public void reduce(Text key,Iterable&lt;Text&gt; values,Context context)throws IOException,InterruptedException {
</span><span class='line'>           ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
</span><span class='line'>           Text left = new Text();
</span><span class='line'>           Text right = new Text();
</span><span class='line'>           right.set("#");
</span><span class='line'>           for(Text value : values){
</span><span class='line'>               array.add(value.toString());
</span><span class='line'>               left.set(key.toString()+"#"+value.toString());
</span><span class='line'>               context.write(left, right);
</span><span class='line'>           }
</span><span class='line'>           for(int i=0; i&lt;array.size(); i++){
</span><span class='line'>               for(int j=i+1; j&lt;array.size(); j++){
</span><span class='line'>                   Text a = new Text();
</span><span class='line'>                   Text b = new Text();
</span><span class='line'>                   if(Integer.parseInt(array.get(i)) &lt; Integer.parseInt(array.get(j))){
</span><span class='line'>                       a.set(array.get(i)+"#"+array.get(j));
</span><span class='line'>                       b.set("&");
</span><span class='line'>                   }
</span><span class='line'>                   else{
</span><span class='line'>                       a.set(array.get(j)+"#"+array.get(i));
</span><span class='line'>                       b.set("&");
</span><span class='line'>                   }
</span><span class='line'>                   context.write(a, b);
</span><span class='line'>               }
</span><span class='line'>           }
</span><span class='line'>       }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  public static class combineMap extends Mapper&lt;LongWritable, Text, Text, Text&gt;{
</span><span class='line'>      private Text a = new Text();
</span><span class='line'>      private Text b = new Text();
</span><span class='line'>      public void map(LongWritable key,Text value,Context context)throws IOException,InterruptedException {
</span><span class='line'>          StringTokenizer itr=new StringTokenizer(value.toString());
</span><span class='line'>          a.set(itr.nextToken().toString());
</span><span class='line'>          b.set(itr.nextToken().toString());
</span><span class='line'>          context.write(a, b);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  public static class combineReducer extends Reducer&lt;Text, Text, Text, Text&gt;{
</span><span class='line'>      private static int result = 0;
</span><span class='line'>      //private Text a = new Text();
</span><span class='line'>      //private Text b = new Text();
</span><span class='line'>      
</span><span class='line'>      public void cleanup(Context context) throws IOException, InterruptedException{
</span><span class='line'>          context.write(new Text("Result: "), new Text(""+result));
</span><span class='line'>      }
</span><span class='line'>      
</span><span class='line'>      public void reduce(Text key,Iterable&lt;Text&gt; values,Context context)throws IOException,InterruptedException {
</span><span class='line'>          int count = 0;
</span><span class='line'>          int is_triangle = 0;
</span><span class='line'>          for(Text value : values){
</span><span class='line'>              if(value.toString().equalsIgnoreCase("#")){
</span><span class='line'>                  is_triangle = 1;
</span><span class='line'>              }else if(value.toString().equalsIgnoreCase("&")){
</span><span class='line'>                  count ++;
</span><span class='line'>              }else{
</span><span class='line'>                  //System.out.println("wrong input number");
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>          if (is_triangle == 1){
</span><span class='line'>              result += count;
</span><span class='line'>          }
</span><span class='line'>          //b.set(result+"");
</span><span class='line'>          //context.write(key, new Text(count+""));
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  public static void main(String[] args) throws Exception {
</span><span class='line'>        // TODO Auto-generated method stub
</span><span class='line'>        Configuration conf=new Configuration();
</span><span class='line'>        String[] otherArgs=new GenericOptionsParser(conf,args).getRemainingArgs();
</span><span class='line'>        if (otherArgs.length!=4) {
</span><span class='line'>            System.err.println("Usage:invertedindex&lt;in&gt; &lt;out1&gt; &lt;out2&gt; &lt;out3&gt;");
</span><span class='line'>            System.exit(2);
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        Job job1 = new Job(conf, "job1");
</span><span class='line'>        job1.setJarByClass(triangle.class);
</span><span class='line'>        job1.setMapperClass(sortMapper.class);
</span><span class='line'>        job1.setMapOutputKeyClass(Text.class);
</span><span class='line'>        job1.setMapOutputValueClass(Text.class);
</span><span class='line'>        job1.setReducerClass(sortReducer.class);
</span><span class='line'>        job1.setOutputKeyClass(Text.class);
</span><span class='line'>        job1.setOutputValueClass(Text.class);
</span><span class='line'>
</span><span class='line'>        //job1.setInputFormatClass(TextInputFormat.class);
</span><span class='line'>        //job1.setOutputFormatClass(TextOutputFormat.class);
</span><span class='line'>        //job1.setMapOutputKeyClass(Text.class);
</span><span class='line'>        //job1.setMapOutputValueClass(Text.class);
</span><span class='line'>        
</span><span class='line'>        FileInputFormat.addInputPath(job1, new Path(otherArgs[0]));
</span><span class='line'>        FileOutputFormat.setOutputPath(job1, new Path(otherArgs[1]));
</span><span class='line'>        
</span><span class='line'>        job1.waitForCompletion(true);
</span><span class='line'>        
</span><span class='line'>
</span><span class='line'>        Job job2 = new Job(conf, "job2");
</span><span class='line'>        job2.setJarByClass(triangle.class);
</span><span class='line'>        job2.setMapperClass(findMap.class);
</span><span class='line'>        job2.setMapOutputKeyClass(Text.class);
</span><span class='line'>        job2.setMapOutputValueClass(Text.class);
</span><span class='line'>        job2.setReducerClass(findReducer.class);
</span><span class='line'>        job2.setOutputKeyClass(Text.class);
</span><span class='line'>        job2.setOutputValueClass(Text.class);
</span><span class='line'>        
</span><span class='line'>        //job2.setInputFormatClass(TextInputFormat.class);
</span><span class='line'>        //job2.setOutputFormatClass(TextOutputFormat.class);
</span><span class='line'>        //job2.setMapOutputKeyClass(Text.class);
</span><span class='line'>        //job2.setMapOutputValueClass(Text.class);
</span><span class='line'>        
</span><span class='line'>        FileInputFormat.addInputPath(job2, new Path(otherArgs[1]));
</span><span class='line'>        FileOutputFormat.setOutputPath(job2, new Path(otherArgs[2]));
</span><span class='line'>        
</span><span class='line'>        job2.waitForCompletion(job1.isComplete());
</span><span class='line'>     
</span><span class='line'>        Job job3 = new Job(conf, "job3");
</span><span class='line'>        job3.setJarByClass(triangle.class);
</span><span class='line'>        job3.setMapperClass(combineMap.class);
</span><span class='line'>        job3.setMapOutputKeyClass(Text.class);
</span><span class='line'>        job3.setMapOutputValueClass(Text.class);
</span><span class='line'>        job3.setReducerClass(combineReducer.class);
</span><span class='line'>        job3.setOutputKeyClass(Text.class);
</span><span class='line'>        job3.setOutputValueClass(Text.class);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        //job3.setInputFormatClass(TextInputFormat.class);
</span><span class='line'>        //job3.setOutputFormatClass(TextOutputFormat.class);
</span><span class='line'>        //job3.setMapOutputKeyClass(Text.class);
</span><span class='line'>        //job3.setMapOutputValueClass(Text.class);
</span><span class='line'>        
</span><span class='line'>        FileInputFormat.addInputPath(job3, new Path(otherArgs[2]));
</span><span class='line'>        FileOutputFormat.setOutputPath(job3, new Path(otherArgs[3]));
</span><span class='line'>        
</span><span class='line'>        job3.waitForCompletion(job2.isComplete());
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vpn添加路由规则+octopress push报错]]></title>
    <link href="http://monkey-h.github.io/blog/net-add/"/>
    <updated>2015-05-07T14:56:51+08:00</updated>
    <id>http://monkey-h.github.io/blog/net-add</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>关于vpn访问局域网内服务器和octopress deploy的时候报错，记录一下，年纪大了，老是忘记怎么做。</p>

<!--more-->


<ul>
<li><p>vpn添加路由规则
国内墙的厉害，没有vpn感觉就活不了，免费的vpn说不定就被封了，干脆买了一个，买的是一个叫做云梯VPN的VPN，用起来速度还可以，但是有一个不好的地方就是，他是转发所有流量的，就是说，他不会做一个判断，所有的流量都通过他的VPN转发出去。比如访问个百度的网址，也是先转到国外他的vpn服务器，然后从那里转发出来，查找国内的百度服务器。这样会相当慢，当然了，也不是很慢，况且我们翻墙主要是为了访问国外的资源，国内基本不怎么访问，也就无所谓了。但是，有一些情况比较特殊，因为我经常要访问我们局域网内的服务器，这就比较麻烦了，因为你转发到国外的服务器上之后，再转发给国内的时候，是找不到我们局域网内的服务器的，这就需要添加一个路由规则，让所有有关访问局域网内的ip的请求，不走vpn，而是走我们局域网内的路由器就可以了。
<code>sudo /sbin/route add -net 114.212 192.168.1.1</code>
114.212是我们局域网的ip地址段，后面的192.168.1.1是路由器的ip地址。</p></li>
<li><p>octopress rake gen_deploy报错
搭建好的octopress，刚开始gen_deploy的时候可以push，但是后来重启了机器，就不可以了，报错
<img src="http://i1066.photobucket.com/albums/u407/5681713/everything/octopress_zpsuen9rm2b.png" alt="" />
经查证，好像是本地的rsa key没有加入到本地的钥匙中，添加进去就可以了。
<code>ssh-add ~/.ssh/id_rsa</code></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在coreos系统下，同时添加flannel和私有仓库的参数]]></title>
    <link href="http://monkey-h.github.io/blog/flannel-registry/"/>
    <updated>2015-05-06T17:07:40+08:00</updated>
    <id>http://monkey-h.github.io/blog/flannel-registry</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>前面我们已经搭建好了一个coreos集群 <a href="http://monkey-h.github.io/blog/coreoschi-xian-an-zhuang/">看这里</a>，正如这篇blog里面说的一样，我们没有外网，所以我们自己搭建了一个私有仓库，方法可以去官网找，很简答的两行命令，这里就不再叙述。既然搭建了私服，我们就希望我们的这个集群使用这个集群。其次，我们搭建了一个集群，我们也希望屏蔽这是一个集群的概念，让用户用起来就像在使用一个主机的服务器一样，所以我们需要<a href="github.com/coreos/flannel">flanel</a>服务。这就涉及到给docker daemon添加多个参数，我们这里记录一下过程。同时，这也是如果在coreos集群中如何运行service的介绍。</p>

<!--more-->


<h4>添加私服参数</h4>

<p>我们的服务器是没有外网的，所以，从docker hub上下载一个镜像都是问题，所以我们搭建了一个私有的docker registry。关于docker registry的东西，其实也是很有意思的，如果以后有机会，我们还会写一篇文章来介绍docker registry。我们现在的方式是，自己建立一个私服，然后从可以连接外网的地方下载一些image，然后上传到私服，这样，就可以直接从我们的私服上下载了，而且速度相当快。因为是局域网内，而且没有经过国防网。
系统默认的docker.service在</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/usr/lib64/systemd/system/docker.service</span></code></pre></td></tr></table></div></figure>


<p>里面，但是这个路径下的文件是可读不可写的，所以我们要把他移动到一个可读可写的地方。不只是docker.service，只要是unit files都要在这个路径</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/etc/systemd/system</span></code></pre></td></tr></table></div></figure>


<p>所以，第一步，拷贝一份docker.service。并编辑。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo cp /usr/lib64/systemd/system/docker.service /etc/systemd/system/
</span><span class='line'>cd /etc/systemd/system
</span><span class='line'>sudo vim docker.service</span></code></pre></td></tr></table></div></figure>


<p>把其中的这句话</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ExecStart=/usr/lib/coreos/dockerd --daemon --host=fd:// $DOCKER_OPTS -- $DOCKER_OPT_BIP $DOCKER_OPT_MTU $DOCKER_OPT_IPMASQ</span></code></pre></td></tr></table></div></figure>


<p>改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ExecStart=/usr/lib/coreos/dockerd --daemon --host=fd:// $DOCKER_OPTS --insecure-registry docker.iwanna.xyz:5000 $DOCKER_OPT_BIP $DOCKER_OPT_MTU $DOCKER_OPT_IPMASQ</span></code></pre></td></tr></table></div></figure>


<p>加的那个参数，就是告诉本机，这个地址的私有仓库可以不走https协议，要不然在pull image的时候会报错。
<img src="http://i1066.photobucket.com/albums/u407/5681713/flannel%20regitstry/insecure_zpsjexwxehm.png" alt="insecure" />
接下来，我们要让这个service生效，然后启动。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo systemctl stop docker.service
</span><span class='line'>sudo systemctl enable /etc/systemd/system/docker.service
</span><span class='line'>sudo systemctl daemon-reload
</span><span class='line'>sudo systemctl start docker.service</span></code></pre></td></tr></table></div></figure>


<p>接下来就可以pull私有仓库里可以编译flannel的image了。在docker hub里面，叫做google/golang是一个支持go语言的image，我在上传到私有仓库的时候，为了名字好记，重新命名了，实际上就是这个image。
<img src="http://i1066.photobucket.com/albums/u407/5681713/flannel%20regitstry/pull_zpsihbxjfxl.png" alt="pull" /></p>

<h4>安装flannel</h4>

<p>现在我们已经从私服上下载下来了编译flannel的image，现在我们需要flannel的源码，由于我们这里不能使用外网，所以，还是通过tomcat的方式下载，如果可以使用外网，可以直接使用git clone来下载</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone https://github.com/coreos/flannel.git</span></code></pre></td></tr></table></div></figure>


<p>我们这里是从tomcat服务器上下载的。
<img src="http://i1066.photobucket.com/albums/u407/5681713/flannel%20regitstry/wget_zpswmf12hii.png" alt="wget" />
接下来，解压，移动到/opt目录，为什么这么做，是为了防止以后误删。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tar -zxf flannel.tar.gz
</span><span class='line'>sudo mkdir /opt
</span><span class='line'>sudo mv flannel/* /opt
</span><span class='line'>cd /opt</span></code></pre></td></tr></table></div></figure>


<p>好了，现在可以编译了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -v /opt:/opt/flannel -ti docker.iwanna.xyz:5000/hmonkey/flannel /bin/bash -c "cd /opt/flannel && ./build"</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i1066.photobucket.com/albums/u407/5681713/flannel%20regitstry/building_zps5vlcndnc.png" alt="building" />
接下来，我们就要创建flannel服务了。
进入到我们的unit files目录。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /etc/systemd/system
</span><span class='line'>sudo touch flannel.service
</span><span class='line'>sudo vim flannel.service</span></code></pre></td></tr></table></div></figure>


<p>在里面写入这样的代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Unit]
</span><span class='line'>Description=flannel
</span><span class='line'>Requires=etcd.service
</span><span class='line'>After=etcd.service
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>ExecStartPre=-/usr/bin/etcdctl mk /coreos.com/network/config '{"Network":"10.0.0.0/16"}'
</span><span class='line'>ExecStart=/opt/bin/flanneld
</span><span class='line'>
</span><span class='line'>[Install]
</span><span class='line'>WantedBy=multi-user.target</span></code></pre></td></tr></table></div></figure>


<p>然后，启动这个服务。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo systemctl enable flannel.service
</span><span class='line'>sudo systemctl start flannel.service</span></code></pre></td></tr></table></div></figure>


<p>可以查看状态，如果是这样，就说明成功了。
<img src="http://i1066.photobucket.com/albums/u407/5681713/flannel%20regitstry/status_zpsk02mrnhs.png" alt="status" />
接下来，停掉docker.service，删除网桥docker0，让docker0使用flannel的网桥，然后修改docker.service，重启docker。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source /run/flannel/subnet.env
</span><span class='line'>sudo systemctl stop docker.service
</span><span class='line'>sudo ifconfig docker0 ${FLANNEL_SUBNET}
</span><span class='line'>sudo vim docker.service
</span><span class='line'>sudo systemctl daemon-reload
</span><span class='line'>sudo systemctl start docker.service</span></code></pre></td></tr></table></div></figure>


<p>编辑docker.service的时候，使得最后，docker.service看起来是这个样子的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Unit]
</span><span class='line'>Description=Docker Application Container Engine
</span><span class='line'>Documentation=http://docs.docker.com
</span><span class='line'>After=docker.socket early-docker.target network.target
</span><span class='line'>Requires=docker.socket early-docker.target
</span><span class='line'>
</span><span class='line'>[Service]
</span><span class='line'>Environment=TMPDIR=/var/tmp
</span><span class='line'>EnvironmentFile=-/run/flannel/subnet.env
</span><span class='line'>MountFlags=slave
</span><span class='line'>LimitNOFILE=1048576
</span><span class='line'>LimitNPROC=1048576
</span><span class='line'>ExecStart=/usr/lib/coreos/dockerd --insecure-registry docker.iwanna.xyz:5000 --bip=${FLANNEL_SUBNET} --mtu=${FLANNEL_MTU} --daemon --host=fd://
</span><span class='line'>
</span><span class='line'>[Install]
</span><span class='line'>WantedBy=multi-user.target</span></code></pre></td></tr></table></div></figure>


<p>好了，大功告成，验证一下。
我们在coreos3上随便跑一个container，可以看到，他的ip是我们之前用flannel获得的。
<img src="http://i1066.photobucket.com/albums/u407/5681713/flannel%20regitstry/try_zpsdxnqxstq.png" alt="try" />
然后我们在coreos1上，ping这个ip，可以看到，完全可以ping通。
<img src="http://i1066.photobucket.com/albums/u407/5681713/flannel%20regitstry/ping_zpsfvnfwq69.png" alt="ping" />
同样的，简单学习一下systemd的语法，就可以让我们开启不同的service，如果这些service中有涉及到有可能修改docker daemon的参数的，就可以通过上面这个例子进行修改。</p>
]]></content>
  </entry>
  
</feed>
