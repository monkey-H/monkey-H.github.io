<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Welcome to monkey-H's blog]]></title>
  <link href="http://monkey-h.github.io/atom.xml" rel="self"/>
  <link href="http://monkey-h.github.io/"/>
  <updated>2015-05-07T17:32:03+08:00</updated>
  <id>http://monkey-h.github.io/</id>
  <author>
    <name><![CDATA[monkey-H]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vpn添加路由规则+octopress Push报错]]></title>
    <link href="http://monkey-h.github.io/blog/net-add/"/>
    <updated>2015-05-07T14:56:51+08:00</updated>
    <id>http://monkey-h.github.io/blog/net-add</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>关于vpn访问局域网内服务器和octopress deploy的时候报错，记录一下，年纪大了，老是忘记怎么做。</p>

<!--more-->


<ul>
<li><p>vpn添加路由规则
国内墙的厉害，没有vpn感觉就活不了，免费的vpn说不定就被封了，干脆买了一个，买的是一个叫做云梯VPN的VPN，用起来速度还可以，但是有一个不好的地方就是，他是转发所有流量的，就是说，他不会做一个判断，所有的流量都通过他的VPN转发出去。比如访问个百度的网址，也是先转到国外他的vpn服务器，然后从那里转发出来，查找国内的百度服务器。这样会相当慢，当然了，也不是很慢，况且我们翻墙主要是为了访问国外的资源，国内基本不怎么访问，也就无所谓了。但是，有一些情况比较特殊，因为我经常要访问我们局域网内的服务器，这就比较麻烦了，因为你转发到国外的服务器上之后，再转发给国内的时候，是找不到我们局域网内的服务器的，这就需要添加一个路由规则，让所有有关访问局域网内的ip的请求，不走vpn，而是走我们局域网内的路由器就可以了。
<code>sudo /sbin/route add -net 114.212 192.168.1.1</code>
114.212是我们局域网的ip地址段，后面的192.168.1.1是路由器的ip地址。</p></li>
<li><p>octopress rake gen_deploy报错
搭建好的octopress，刚开始gen_deploy的时候可以push，但是后来重启了机器，就不可以了，报错
<img src="http://i1066.photobucket.com/albums/u407/5681713/everything/octopress_zpsuen9rm2b.png" alt="" />
经查证，好像是本地的rsa key没有加入到本地的钥匙中，添加进去就可以了。
<code>ssh-add ~/.ssh/id_rsa</code></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建不需要输入密码就可以登录的docker Image]]></title>
    <link href="http://monkey-h.github.io/blog/ssh-image/"/>
    <updated>2015-05-06T16:55:39+08:00</updated>
    <id>http://monkey-h.github.io/blog/ssh-image</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>ssh进入某一个机器的时候，要么提供那台机器的密码，要么采用别的安全协议，比如说rsa协议，我们就是通过rsa协议实现了不输入密码就可以直接登录别的主机。这样做主要是为了，我们在利用mpi进行计算的时候，不能通过输入密码的方式进行访问，所以，有这个需求。</p>

<!--more-->


<p>而rsa的工作原理是什么样子的呢？简单说来，如果a想ssh到b上去，那么a就要把自己的rsa.pub发送给b，然后，b如果接受a以后可以无密码访问我，就把这个pub key加入到authorized_keys里面去，这样以后，在a想ssh到b的时候，a会把这个信息进行加密，通过a自身的private key，而a的这个加密信息只有a的pub key才能解开，这样，b在接收到这个信息的时候，因为b拥有a的pub key，所以就可以解开，同样地，b也就知道，这真是a发来的信息，因为别的人不知道a的private key，这样b就可以直接允许a ssh进来了。
在docker环境中，我们比较方便的地方，是可以直接制作一个镜像。我们的想法是，用一个基础镜像构建一个container，然后在这个container里面生成rsa密钥，然后，把自己的pub key直接拷到authorized_keys里面去，然后把这个container做成一个镜像，这样的话，只要从这个镜像起来的container，都可以互相无密码访问。
首先，要用docker启用一个container</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -ti ubuntu /bin/bash</span></code></pre></td></tr></table></div></figure>


<p>既然要使用ssh，那么我们肯定要安装ssh。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install openssh-server</span></code></pre></td></tr></table></div></figure>


<p>然后，生成密钥，并且赋值给authorized_keys</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sshkey-gen -t rsa</span></code></pre></td></tr></table></div></figure>


<p>一直按回车，不要停。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cp /root/.ssh/id_dsa.pub /root/.ssh/authorized_keys</span></code></pre></td></tr></table></div></figure>


<p>修改一些配置信息，修改/etc/ssh/ssh_configure文件里面的StrictHostKeyChecking ask为 no，这个配置信息是在ssh主机的时候，询问加入fingerprint的那个东西。
然后退出container，使用docker ps -l查看刚刚退出的container的id，然后用这个container commit一个镜像。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker commit container_id image_name</span></code></pre></td></tr></table></div></figure>


<p>那么最终生成的那个image_name，就是我们设计出来的一个image，从这个image启动不同的container之后，在开启了ssh服务的情况下，是可以相互不输入密码ssh进去的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用vagrant搭建coreos集群安装flannel服务并使用mpi测试]]></title>
    <link href="http://monkey-h.github.io/blog/shi-yong-vagrantda-jian-coreosji-qun-an-zhuang-flannelfu-wu-bing-shi-yong-mpi-benchmarkce-shi/"/>
    <updated>2015-05-06T15:20:00+08:00</updated>
    <id>http://monkey-h.github.io/blog/shi-yong-vagrantda-jian-coreosji-qun-an-zhuang-flannelfu-wu-bing-shi-yong-mpi-benchmarkce-shi</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>容器技术已经成为了当前技术的潮流，学习容器技术已经刻不容缓。除了原始的warden容器，docker容器之外，coreos也在发展自己的容器技术，rocket，就连之前不看好容器技术的microsoft也开始创建自己的容器技术，nano server。我们这里尝试搭建coreos集群，并安装了flannel服务，用来实现mpi程序的测试。</p>

<!--more-->


<h4>需要的软件支持</h4>

<p>我们采用的是使用vagrant + virtualbox的方式来搭建coreos集群，所以，这两个软件的正确安装是必不可少的。</p>

<h4>coreos集群安装</h4>

<p>在之前的blog <a href="http://monkey-h.github.io/blog/coreoschi-xian-an-zhuang/">coreos离线安装</a> 里面，我们已经在服务器上安装了coreos集群，但是并不是所有的同学都有这么多资源，可以有那么多的服务器可以使用。通过搭建虚拟机的方式又很慢，所以，我们这里采用vagrant + virtualbox的方式来搭建集群。
使用vagrant搭建coreos集群官网，官网上有coreos集群通过vagrant搭建的具体步骤，基本没有什么坑，我们这里简单说明一下。
首先，在宿主机目录下，下载coreos-vagrant的git代码，并进入代码目录。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone https://github.com/coreos/coreos-vagrant.git
</span><span class='line'>cd coreos-vagrant</span></code></pre></td></tr></table></div></figure>


<p>接着，我们就可以修改其中的某些参数，来搭建我们的集群了。
首先，把示例代码拷贝一下，我们这里直接重命名了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mv user-data.sample user-data
</span><span class='line'>mv config.ruby.sample config.ruby</span></code></pre></td></tr></table></div></figure>


<p>接着，修改两个文件的参数。打开config.ruby，把里面的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#$num_instance=1</span></code></pre></td></tr></table></div></figure>


<p>改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$num_instance=3</span></code></pre></td></tr></table></div></figure>


<p>因为我们搭建的集群如果只有一台机器，是没有意义的。
还有把</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#$update_channel='alpha'</span></code></pre></td></tr></table></div></figure>


<p>改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$update_channel='stable'</span></code></pre></td></tr></table></div></figure>


<p>我们还是使用比较稳定的版本较好，免得出现乱起八糟的问题。
打开user-data，把里面的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#discovery: https://discovery.etcd.io/&lt;token&gt;</span></code></pre></td></tr></table></div></figure>


<p>改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>discovery: https://discovery.etcd.io/&lt;token&gt;</span></code></pre></td></tr></table></div></figure>


<p>至于是怎么来的，你可以访问这个网址，这个网址可以自动生成一个唯一的，用来达到建立集群的目的。至于这个东西有什么用，可以去查etcd的文档，简单来说，就是每个启动的机器都会去找这个token，找到了，就连接到这个集群中，从而实现集群的建立。
打开Vagrantfile，修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>config.vm.box_version "&gt;= 308.0.1"</span></code></pre></td></tr></table></div></figure>


<p>为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#config.vm.box_version "&gt;= 308.0.1"</span></code></pre></td></tr></table></div></figure>


<p>就是把他删掉，因为后面可能会报这个错误，这个又不是必须的，我们就直接删掉。
好了，该修改的都修改了，这个时候，就可以大胆的启动了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant up</span></code></pre></td></tr></table></div></figure>


<h4>flannel搭建</h4>

<p>vagrant搭建完成后，我们就可以进入搭建好的coreos主机了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant ssh core-01 -- -A</span></code></pre></td></tr></table></div></figure>


<p>分别进入三个主机，三个主机的名字分别为core-01，core-02，core-03。现在假如我们进入了core-01。我们可以在里面看到集群中所有的机器。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fleetctl list-machines</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i1066.photobucket.com/albums/u407/5681713/coreos/list_zpshwqj6n0d.png" alt="list" />
可以看到，集群中一共有三台机器，ip也都是知道的。接着，让我们来安装flannel服务。在每台机器里，都这么做。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /
</span><span class='line'>git clone https://github.com/coreos/flannel.git
</span><span class='line'>mv /flannel /opt
</span><span class='line'>cd opt
</span><span class='line'>sudo docker run -v /opt:/opt/flannel -ti google/golang /bin/bash -c "cd /opt/flannel && ./build"</span></code></pre></td></tr></table></div></figure>


<p>然后，采用etcd的键值对服务，设置全局子网域。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>etcdctl rm /coreos.com/network --recursive
</span><span class='line'>etcdctl mk /coreos.com/network/config '{"Network":"10.0.0.0/16"}'</span></code></pre></td></tr></table></div></figure>


<p>然后启动flannel服务。注意，我们在启动集群的时候，eth0网卡是通过nat方式和host主机连在一起的，但是，eth1是和别的host主机在同一个局域网的网卡，所以我们在启动flannel服务的时候，要制定eth1网卡。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo /opt/bin/flanneld -iface=eth1 &</span></code></pre></td></tr></table></div></figure>


<p>flannel启动。在core-02和core-03上运行相同的过程。但是我们的docker并没有使用指定的子网，所以，我们还要重新运行docker，让他使用我们指定的子网。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source /run/flannel/subnet.env
</span><span class='line'>sudo rm /var/run/docker.pid
</span><span class='line'>sudo ifconfig docker0 ${FLANNEL_SUBNET}
</span><span class='line'>sudo docker -d --bip=${FLANNEL_SUBNET} --mtu=${FLANNEL_MTU}</span></code></pre></td></tr></table></div></figure>


<p>大功告成，检验一下，<code>ifconfig</code>
<img src="http://i1066.photobucket.com/albums/u407/5681713/coreos/flannel_zpspjmjfrk6.png" alt="" />
这里可以看到，我们的flannel0已经建成。同时
<img src="http://i1066.photobucket.com/albums/u407/5681713/coreos/docker_zpsqy85ijfh.png" alt="" />
docker0也已经是我们指定的ip了。</p>

<h4>mpi应用测试</h4>

<p>我在dockerhub上上传了一个关于mpi的镜像，我们这里可以下载下来运行一下。
在core-01上，运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -ti --name master hmonkey/openmpi14.04:v3 /bin/bash</span></code></pre></td></tr></table></div></figure>


<p>在core-02上运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -ti --name slave1 hmonkey/openmpi14.04:v3 /bin/bash</span></code></pre></td></tr></table></div></figure>


<p>在core-03上运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -ti --name slave2 hmonkey/openmpi14.04:v3 /bin/bash</span></code></pre></td></tr></table></div></figure>


<p>然后在core-01上，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /mpi`
</span><span class='line'>touch hostfile
</span><span class='line'>vi hostfile //在里面添加slave1和slave2的ip地址。
</span><span class='line'>mpirun -n 3 -hostfile hostfile mpi_hello</span></code></pre></td></tr></table></div></figure>


<p>大功告成，结果如下
<img src="http://i1066.photobucket.com/albums/u407/5681713/coreos/mpi_zps1vidqse2.png" alt="" />
要注意的是，我的mpi镜像忘记默认启动ssh服务了。如果运行mpi应用的时候包connect refused，把ssh服务打开就可以了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash 脚本语言学习收获]]></title>
    <link href="http://monkey-h.github.io/blog/bash-trick/"/>
    <updated>2015-04-29T19:12:01+08:00</updated>
    <id>http://monkey-h.github.io/blog/bash-trick</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>之前一直以为脚本语言就是简单的一种编程语言，不需要过多的了解，只要知道一点皮毛，哪里用到哪里学习一下就可以了，但是，读了一段牛人写的bash脚本程序之后，看不懂，查了bash的基本语法，才知道，原来bash是这么牛掰的一门语言，准备花两天系统学习一下，今天看了一部分，记录一下自己觉得很有意思，之前不知道的东西。</p>

<!--more-->


<h3>学习笔记</h3>

<ol>
<li><p>bash执行脚本的时候，会fork出来一个subshell来执行。那么，在脚本里设置的一些变量，就只有那个subshell知道，别的都不知道，也就是说，会被直接遗忘掉。使用export也是一样的效果。同时，注意在赋值的时候，是hello=”1”，不要忘记了没有空格和要有双引号。</p></li>
<li><p>如果不想开一个新的subshell来执行脚本，可以使用source script.sh这样来执行，这样就会在这个shell进程里来执行脚本，这样就可以保留里面设置的变量，包括export的环境变量，但是，结束了这个终端，也是不会被保留的。source在bash里面，可以使用.来替代。. script.sh也能达到这样的效果。</p></li>
<li><p>脚本文件第一行的#！尽量不要省略，这一行代表了这个脚本通过什么脚本命令程序来执行，如果你希望通过bash来执行脚本，但是没有指定，系统默认的又是别的脚本程序，那么就很有可能会出错。</p></li>
<li><p>当脚本出错的时候，如果想调试，没必要到脚本文件里面，通过注释代码的方式来调试，可以使用-x命令，bash -x script.sh来调试，这样，会让脚本文件一步一步执行，并在执行每一行命令前，打印出执行的哪一句命令，同时可以在脚本文件里加上，set -x …. set +x，来在常规执行的时候，就进入debug模式的一段代码。</p></li>
<li><p>按照惯例，bash的变量一般都是大写字母的组合，bash的变量有两种，一种是global variable，可以通过env或者printenv来查看，这些变量是在所有的shell里面都共用的。还有一种叫做local variable，这种变量只有在当前shell才有用。变量不能以数字开头。再次强调，在赋值的时候，等号周围是不能有空格的。可以通过unset 变量的方式，来把原来赋给变量的值清除掉。</p></li>
<li><p>一些特殊的值</p>

<ul>
<li>$0 当前脚本的名字，或者终端的名字。</li>
<li>$n 其中，n可以是1，2，3等，代表传入脚本的参数的值，不是从0开始的。</li>
<li>$# 参数的总个数。</li>
<li>$$ bash的进程id</li>
<li>$! 最近执行的后台命令的进程ID</li>
</ul>
</li>
<li><p>单引号可以让一些变量保持字面含义，比如echo ‘$date’ 输出是$date，而不是日期，同时，注意单引号不能嵌套单引号。但是双引号就不同了，双引号内，可以嵌套双引号，同时，如果加了$，是可以引用变量的，比如echo “$date” 输出的就不是$date，而是现在的日期。除了$，还有’’，echo “‘date’”和加$一样呢的效果。</p></li>
<li><p>一些小的trick
 echo sp{el,il,al}l
 spell spill spall
 (大括号的优先级是最高的)
 ~常被用来解析成$HOME，如~/path等。有两个特殊的应用~+代表的是当前路径，~-代表的是上一次进入的路径。
 允许通过:=的方式赋值，比如echo ${FRANKY:=FRIDY} 输出 FRIDY
 假如使用了”$(COMMAND)”的方式，那么，其中的所有字符都会被当做命令，而不会特殊处理。
 如果想在命令里进行计算，有两种方式，$((2+2)) 或者$[2+2]这两种方式，echo这两个结果，都是4</p></li>
<li><p>这是一个神奇的命令，是替代，别名的意思，我们可以使用这个东西来简化命令。
 比如，cd ../是回到上一层目录，假如我们使用alias ..=’cd ../’，然后，以后只要打..就可以回到上一层，如果想去除这个简写，只要unalias ..就可以了。当然这个修改只是暂时的，如果想一直这么做，就需要修改./bashrc或者/etc/profile文件。</p></li>
<li><p>正则表达式</p>

<ul>
<li>. 配对单个字符</li>
<li>? 代表最多一个字符，要么匹配，要么没有。</li>
<li>* 任意多个字符，可以没有一个</li>
<li>+ 和*一样，但是至少要匹配一次。</li>
<li>{N} 精确匹配N次</li>
<li>{N,} 精确匹配至少N次</li>
<li>{N,M} 精确匹配N到M次即可。</li>
<li>\ 下一个字符标记为一个特殊字符</li>
<li>| 匹配两边中的一个。</li>
<li>[xyz] 匹配其中的任意一个字符</li>
<li>[^ xyz] 匹配不是这三个中的字符，任意个</li>
<li>^xx 匹配某一行xx开头的文字</li>
<li>xx$ 匹配某一行xx结尾的文字</li>
<li>&lt;xx 某一个单词是xx开头的</li>
<li>>xx 某一个单词是xx结尾的。</li>
<li>- 表示范围。常用的就这么多，还有很多，百度一下，google一下就出来了。</li>
</ul>
</li>
<li><p>sed 是stream editor的简称，是一个编译器，具有很NB的功能。要注意的是，sed并没有修改文档的内容，只是打印修改后的文档。
基本命令：</p>

<ul>
<li>a 在当前行下添加文本</li>
<li>c 当前行变换内容</li>
<li>d 删除文本</li>
<li>i 当前行前增加文本</li>
<li>p 打印文本</li>
<li>r 读一个文件</li>
<li>s 查找并替代文本</li>
<li>w 写到一个文件
举个例子， <code>sed ‘/erors/p’ example</code>的意思就是，在example文件里面，查找有erors的行，并打印出来，假如我们这么写，那么就会把所有的文本都打印出来，只不过，有erors的行，打印两遍，所以我们要这么写<code>sed -n ‘erors/p’ example</code>
假如要删除，<code>sed ’/erors/d’ example</code>，这样就会删除有erors的行。
假如我们知道要删除的行是第几行，可以通过这么删除，<code>sed ‘2,4d’ example</code> 这样就删除了2-4行。同时可以使用正则表达式等。
<code>sed -n ‘/a text/,/This/p’ example</code>，这句话的意思就是，从example中匹配，打印从第一个包含a text的行，到保护This的那一行截止。
<code>sed ‘s/erors/errors’ example</code> 查找并替代。但是这样只会替代第一行，如果要替代所有的，需要<code>sed ‘s/erors/errors/g’ example</code>
如果多次查找和替换，需要使用-e参数。
<code>sed -e ‘s/erors/erros/g’ -e ‘s/last/final/g’ example</code>
同时，可以将结果输出到某一个文件。使用>即可。</li>
</ul>
</li>
<li><p>if语句。
注意在if [  ]的方括号里面，括号的左右是要有空格的。
常用的用来判断文件的一些参数。</p>

<ul>
<li>-a 存在即为真</li>
<li>-d 是否是个目录</li>
<li>-e 是否存在</li>
<li>-f 是否存在，且是一个常规文件</li>
<li>-r 是否可读</li>
<li>-s 是否大小不为0</li>
<li>-w 是否可写</li>
<li>-z 如果后面的string长度为0</li>
<li>-n 如果后面的string长度不为0</li>
<li>-x 是否有执行权限
<code>if [ -f /home/monkey/hello ]</code>
<code>then</code>
<code>echo “file exist”</code>
<code>fi</code>
可以写成
<code>if [ -f /home/monkey/hello ]; then</code>
<code>echo “file exist</code>
<code>fi</code>
可以写成
<code>[ -f /home/monkey/hello ] &amp;&amp; (echo “file exist”)</code>
如果是当条件不满足做什么东西的时候，就是用||。
但是，一般很少用这种代码，大部分都会采用test这个内置命令，来检验一些问题。比如
上面的判断语句可以改为
<code>test -f /home/monkey/hello &amp;&amp; echo file exist</code></li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://monkey-h.github.io/blog/hello-world/"/>
    <updated>2015-04-28T17:46:50+08:00</updated>
    <id>http://monkey-h.github.io/blog/hello-world</id>
    <content type="html"><![CDATA[<p><code>hello! world</code></p>
]]></content>
  </entry>
  
</feed>
